
FreeRTOS_ArduinoMEGA-Demo_AVR323.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000b8  00800200  000024cc  00002560  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000024cc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001dea  008002b8  008002b8  00002618  2**0
                  ALLOC
  3 .stab         000062dc  00000000  00000000  00002618  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003ec0  00000000  00000000  000088f4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	90 c0       	rjmp	.+288    	; 0x126 <__bad_interrupt>
       6:	00 00       	nop
       8:	8e c0       	rjmp	.+284    	; 0x126 <__bad_interrupt>
       a:	00 00       	nop
       c:	8c c0       	rjmp	.+280    	; 0x126 <__bad_interrupt>
       e:	00 00       	nop
      10:	8a c0       	rjmp	.+276    	; 0x126 <__bad_interrupt>
      12:	00 00       	nop
      14:	88 c0       	rjmp	.+272    	; 0x126 <__bad_interrupt>
      16:	00 00       	nop
      18:	86 c0       	rjmp	.+268    	; 0x126 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	84 c0       	rjmp	.+264    	; 0x126 <__bad_interrupt>
      1e:	00 00       	nop
      20:	82 c0       	rjmp	.+260    	; 0x126 <__bad_interrupt>
      22:	00 00       	nop
      24:	80 c0       	rjmp	.+256    	; 0x126 <__bad_interrupt>
      26:	00 00       	nop
      28:	7e c0       	rjmp	.+252    	; 0x126 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7c c0       	rjmp	.+248    	; 0x126 <__bad_interrupt>
      2e:	00 00       	nop
      30:	7a c0       	rjmp	.+244    	; 0x126 <__bad_interrupt>
      32:	00 00       	nop
      34:	78 c0       	rjmp	.+240    	; 0x126 <__bad_interrupt>
      36:	00 00       	nop
      38:	76 c0       	rjmp	.+236    	; 0x126 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	74 c0       	rjmp	.+232    	; 0x126 <__bad_interrupt>
      3e:	00 00       	nop
      40:	72 c0       	rjmp	.+228    	; 0x126 <__bad_interrupt>
      42:	00 00       	nop
      44:	1c c4       	rjmp	.+2104   	; 0x87e <__vector_17>
      46:	00 00       	nop
      48:	6e c0       	rjmp	.+220    	; 0x126 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6c c0       	rjmp	.+216    	; 0x126 <__bad_interrupt>
      4e:	00 00       	nop
      50:	6a c0       	rjmp	.+212    	; 0x126 <__bad_interrupt>
      52:	00 00       	nop
      54:	68 c0       	rjmp	.+208    	; 0x126 <__bad_interrupt>
      56:	00 00       	nop
      58:	66 c0       	rjmp	.+204    	; 0x126 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	64 c0       	rjmp	.+200    	; 0x126 <__bad_interrupt>
      5e:	00 00       	nop
      60:	62 c0       	rjmp	.+196    	; 0x126 <__bad_interrupt>
      62:	00 00       	nop
      64:	a7 c0       	rjmp	.+334    	; 0x1b4 <__vector_25>
      66:	00 00       	nop
      68:	5f c0       	rjmp	.+190    	; 0x128 <__vector_26>
      6a:	00 00       	nop
      6c:	5c c0       	rjmp	.+184    	; 0x126 <__bad_interrupt>
      6e:	00 00       	nop
      70:	5a c0       	rjmp	.+180    	; 0x126 <__bad_interrupt>
      72:	00 00       	nop
      74:	58 c0       	rjmp	.+176    	; 0x126 <__bad_interrupt>
      76:	00 00       	nop
      78:	56 c0       	rjmp	.+172    	; 0x126 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	54 c0       	rjmp	.+168    	; 0x126 <__bad_interrupt>
      7e:	00 00       	nop
      80:	52 c0       	rjmp	.+164    	; 0x126 <__bad_interrupt>
      82:	00 00       	nop
      84:	50 c0       	rjmp	.+160    	; 0x126 <__bad_interrupt>
      86:	00 00       	nop
      88:	4e c0       	rjmp	.+156    	; 0x126 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4c c0       	rjmp	.+152    	; 0x126 <__bad_interrupt>
      8e:	00 00       	nop
      90:	4a c0       	rjmp	.+148    	; 0x126 <__bad_interrupt>
      92:	00 00       	nop
      94:	48 c0       	rjmp	.+144    	; 0x126 <__bad_interrupt>
      96:	00 00       	nop
      98:	46 c0       	rjmp	.+140    	; 0x126 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	44 c0       	rjmp	.+136    	; 0x126 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	42 c0       	rjmp	.+132    	; 0x126 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	40 c0       	rjmp	.+128    	; 0x126 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3e c0       	rjmp	.+124    	; 0x126 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3c c0       	rjmp	.+120    	; 0x126 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	3a c0       	rjmp	.+116    	; 0x126 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	38 c0       	rjmp	.+112    	; 0x126 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	36 c0       	rjmp	.+108    	; 0x126 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	34 c0       	rjmp	.+104    	; 0x126 <__bad_interrupt>
      be:	00 00       	nop
      c0:	32 c0       	rjmp	.+100    	; 0x126 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	30 c0       	rjmp	.+96     	; 0x126 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2e c0       	rjmp	.+92     	; 0x126 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2c c0       	rjmp	.+88     	; 0x126 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	2a c0       	rjmp	.+84     	; 0x126 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	28 c0       	rjmp	.+80     	; 0x126 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	26 c0       	rjmp	.+76     	; 0x126 <__bad_interrupt>
      da:	00 00       	nop
      dc:	24 c0       	rjmp	.+72     	; 0x126 <__bad_interrupt>
      de:	00 00       	nop
      e0:	22 c0       	rjmp	.+68     	; 0x126 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	ec ec       	ldi	r30, 0xCC	; 204
      fc:	f4 e2       	ldi	r31, 0x24	; 36
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a8 3b       	cpi	r26, 0xB8	; 184
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	10 e2       	ldi	r17, 0x20	; 32
     110:	a8 eb       	ldi	r26, 0xB8	; 184
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a2 3a       	cpi	r26, 0xA2	; 162
     11a:	b1 07       	cpc	r27, r17
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	0e 94 16 11 	call	0x222c	; 0x222c <main>
     122:	0c 94 64 12 	jmp	0x24c8	; 0x24c8 <_exit>

00000126 <__bad_interrupt>:
     126:	6c cf       	rjmp	.-296    	; 0x0 <__vectors>

00000128 <__vector_26>:
	}
}
/*-----------------------------------------------------------*/

ISR( USART0_UDRE_vect )
{
     128:	1f 92       	push	r1
     12a:	0f 92       	push	r0
     12c:	0f b6       	in	r0, 0x3f	; 63
     12e:	0f 92       	push	r0
     130:	0b b6       	in	r0, 0x3b	; 59
     132:	0f 92       	push	r0
     134:	11 24       	eor	r1, r1
     136:	2f 93       	push	r18
     138:	3f 93       	push	r19
     13a:	4f 93       	push	r20
     13c:	5f 93       	push	r21
     13e:	6f 93       	push	r22
     140:	7f 93       	push	r23
     142:	8f 93       	push	r24
     144:	9f 93       	push	r25
     146:	af 93       	push	r26
     148:	bf 93       	push	r27
     14a:	ef 93       	push	r30
     14c:	ff 93       	push	r31
     14e:	df 93       	push	r29
     150:	cf 93       	push	r28
     152:	0f 92       	push	r0
     154:	0f 92       	push	r0
     156:	cd b7       	in	r28, 0x3d	; 61
     158:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
     15a:	80 91 ba 02 	lds	r24, 0x02BA
     15e:	90 91 bb 02 	lds	r25, 0x02BB
     162:	be 01       	movw	r22, r28
     164:	6f 5f       	subi	r22, 0xFF	; 255
     166:	7f 4f       	sbci	r23, 0xFF	; 255
     168:	ae 01       	movw	r20, r28
     16a:	4e 5f       	subi	r20, 0xFE	; 254
     16c:	5f 4f       	sbci	r21, 0xFF	; 255
     16e:	78 d6       	rcall	.+3312   	; 0xe60 <xQueueReceiveFromISR>
     170:	81 30       	cpi	r24, 0x01	; 1
     172:	21 f4       	brne	.+8      	; 0x17c <__vector_26+0x54>
     174:	89 81       	ldd	r24, Y+1	; 0x01
	{
		/* Send the next character queued for Tx. */
		UDR0 = cChar;
     176:	80 93 c6 00 	sts	0x00C6, r24
     17a:	05 c0       	rjmp	.+10     	; 0x186 <__vector_26+0x5e>
     17c:	80 91 c1 00 	lds	r24, 0x00C1
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterrupt0Off();
     180:	8f 7d       	andi	r24, 0xDF	; 223
     182:	80 93 c1 00 	sts	0x00C1, r24
     186:	0f 90       	pop	r0
	}
}
     188:	0f 90       	pop	r0
     18a:	cf 91       	pop	r28
     18c:	df 91       	pop	r29
     18e:	ff 91       	pop	r31
     190:	ef 91       	pop	r30
     192:	bf 91       	pop	r27
     194:	af 91       	pop	r26
     196:	9f 91       	pop	r25
     198:	8f 91       	pop	r24
     19a:	7f 91       	pop	r23
     19c:	6f 91       	pop	r22
     19e:	5f 91       	pop	r21
     1a0:	4f 91       	pop	r20
     1a2:	3f 91       	pop	r19
     1a4:	2f 91       	pop	r18
     1a6:	0f 90       	pop	r0
     1a8:	0b be       	out	0x3b, r0	; 59
     1aa:	0f 90       	pop	r0
     1ac:	0f be       	out	0x3f, r0	; 63
     1ae:	0f 90       	pop	r0
     1b0:	1f 90       	pop	r1
     1b2:	18 95       	reti

000001b4 <__vector_25>:
 * INTERRUPTS
 *-----------------------------------------------------------
 */

ISR( USART0_RX_vect )
{
     1b4:	1f 92       	push	r1
     1b6:	0f 92       	push	r0
     1b8:	0f b6       	in	r0, 0x3f	; 63
     1ba:	0f 92       	push	r0
     1bc:	0b b6       	in	r0, 0x3b	; 59
     1be:	0f 92       	push	r0
     1c0:	11 24       	eor	r1, r1
     1c2:	2f 93       	push	r18
     1c4:	3f 93       	push	r19
     1c6:	4f 93       	push	r20
     1c8:	5f 93       	push	r21
     1ca:	6f 93       	push	r22
     1cc:	7f 93       	push	r23
     1ce:	8f 93       	push	r24
     1d0:	9f 93       	push	r25
     1d2:	af 93       	push	r26
     1d4:	bf 93       	push	r27
     1d6:	ef 93       	push	r30
     1d8:	ff 93       	push	r31
     1da:	df 93       	push	r29
     1dc:	cf 93       	push	r28
     1de:	0f 92       	push	r0
     1e0:	0f 92       	push	r0
     1e2:	cd b7       	in	r28, 0x3d	; 61
     1e4:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
unsigned char ucChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;

	/* If some problem occurred (Frame Error, Data Overrun or Parity), just flush the buffer and move on */
	ucChar = UCSR0A;
     1e6:	80 91 c0 00 	lds	r24, 0x00C0
	if (ucChar & (serFRAME_ERROR_BIT | serOVERRUN_ERROR_BIT | serPARITY_ERROR_BIT))
     1ea:	8c 71       	andi	r24, 0x1C	; 28
     1ec:	19 f4       	brne	.+6      	; 0x1f4 <__vector_25+0x40>
     1ee:	07 c0       	rjmp	.+14     	; 0x1fe <__vector_25+0x4a>
	{
		while ( UCSR0A & serRECEIVE_COMPLETE) cChar = UDR0;
     1f0:	80 91 c6 00 	lds	r24, 0x00C6
     1f4:	80 91 c0 00 	lds	r24, 0x00C0
     1f8:	87 fd       	sbrc	r24, 7
     1fa:	fa cf       	rjmp	.-12     	; 0x1f0 <__vector_25+0x3c>
     1fc:	14 c0       	rjmp	.+40     	; 0x226 <__vector_25+0x72>
	else
	{
		/* Get the character and post it on the queue of Rxed characters.
		If the post causes a task to wake force a context switch as the woken task
		may have a higher priority than the task we have interrupted. */
		cChar = UDR0;
     1fe:	80 91 c6 00 	lds	r24, 0x00C6
     202:	89 83       	std	Y+1, r24	; 0x01

		xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
     204:	80 91 b8 02 	lds	r24, 0x02B8
     208:	90 91 b9 02 	lds	r25, 0x02B9

ISR( USART0_RX_vect )
{
signed char cChar;
unsigned char ucChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     20c:	1a 82       	std	Y+2, r1	; 0x02
		/* Get the character and post it on the queue of Rxed characters.
		If the post causes a task to wake force a context switch as the woken task
		may have a higher priority than the task we have interrupted. */
		cChar = UDR0;

		xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
     20e:	be 01       	movw	r22, r28
     210:	6f 5f       	subi	r22, 0xFF	; 255
     212:	7f 4f       	sbci	r23, 0xFF	; 255
     214:	ae 01       	movw	r20, r28
     216:	4e 5f       	subi	r20, 0xFE	; 254
     218:	5f 4f       	sbci	r21, 0xFF	; 255
     21a:	20 e0       	ldi	r18, 0x00	; 0
     21c:	6d d6       	rcall	.+3290   	; 0xef8 <xQueueGenericSendFromISR>
     21e:	8a 81       	ldd	r24, Y+2	; 0x02

		if( xHigherPriorityTaskWoken != pdFALSE )
     220:	88 23       	and	r24, r24
     222:	09 f0       	breq	.+2      	; 0x226 <__vector_25+0x72>
     224:	2e d3       	rcall	.+1628   	; 0x882 <vPortYield>
		{
			taskYIELD();
     226:	0f 90       	pop	r0
     228:	0f 90       	pop	r0
		}
	}
}
     22a:	cf 91       	pop	r28
     22c:	df 91       	pop	r29
     22e:	ff 91       	pop	r31
     230:	ef 91       	pop	r30
     232:	bf 91       	pop	r27
     234:	af 91       	pop	r26
     236:	9f 91       	pop	r25
     238:	8f 91       	pop	r24
     23a:	7f 91       	pop	r23
     23c:	6f 91       	pop	r22
     23e:	5f 91       	pop	r21
     240:	4f 91       	pop	r20
     242:	3f 91       	pop	r19
     244:	2f 91       	pop	r18
     246:	0f 90       	pop	r0
     248:	0b be       	out	0x3b, r0	; 59
     24a:	0f 90       	pop	r0
     24c:	0f be       	out	0x3f, r0	; 63
     24e:	0f 90       	pop	r0
     250:	1f 90       	pop	r1
     252:	18 95       	reti

00000254 <xSerialPutChar>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )
{
     254:	df 93       	push	r29
     256:	cf 93       	push	r28
     258:	0f 92       	push	r0
     25a:	cd b7       	in	r28, 0x3d	; 61
     25c:	de b7       	in	r29, 0x3e	; 62
     25e:	69 83       	std	Y+1, r22	; 0x01
	/* Only one port is supported by now. */
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
     260:	80 91 ba 02 	lds	r24, 0x02BA
     264:	90 91 bb 02 	lds	r25, 0x02BB
     268:	be 01       	movw	r22, r28
     26a:	6f 5f       	subi	r22, 0xFF	; 255
     26c:	7f 4f       	sbci	r23, 0xFF	; 255
     26e:	20 e0       	ldi	r18, 0x00	; 0
     270:	a5 d7       	rcall	.+3914   	; 0x11bc <xQueueGenericSend>
     272:	81 30       	cpi	r24, 0x01	; 1
     274:	11 f0       	breq	.+4      	; 0x27a <xSerialPutChar+0x26>
     276:	80 e0       	ldi	r24, 0x00	; 0
     278:	06 c0       	rjmp	.+12     	; 0x286 <xSerialPutChar+0x32>
     27a:	80 91 c1 00 	lds	r24, 0x00C1
	{
		return pdFAIL;
	}

	vInterrupt0On();
     27e:	80 62       	ori	r24, 0x20	; 32
     280:	80 93 c1 00 	sts	0x00C1, r24
     284:	81 e0       	ldi	r24, 0x01	; 1
     286:	0f 90       	pop	r0

	return pdPASS;
}
     288:	cf 91       	pop	r28
     28a:	df 91       	pop	r29
     28c:	08 95       	ret

0000028e <xSerialGetChar>:
	/* Only one port is supported by now. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
     28e:	80 91 b8 02 	lds	r24, 0x02B8
     292:	90 91 b9 02 	lds	r25, 0x02B9
     296:	20 e0       	ldi	r18, 0x00	; 0
     298:	ca d6       	rcall	.+3476   	; 0x102e <xQueueGenericReceive>
     29a:	81 11       	cpse	r24, r1
     29c:	81 e0       	ldi	r24, 0x01	; 1
     29e:	08 95       	ret

000002a0 <xSerialPortInitMinimal>:
	UCSR0B = ucInByte;										\
}
/*-----------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( uint32_t ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
     2a0:	df 92       	push	r13
     2a2:	ef 92       	push	r14
     2a4:	ff 92       	push	r15
     2a6:	0f 93       	push	r16
     2a8:	1f 93       	push	r17
     2aa:	7b 01       	movw	r14, r22
     2ac:	8c 01       	movw	r16, r24
     2ae:	d4 2e       	mov	r13, r20
uint32_t ulBaudRateCounter;
unsigned char ucByte;

	portENTER_CRITICAL();
     2b0:	0f b6       	in	r0, 0x3f	; 63
     2b2:	f8 94       	cli
     2b4:	0f 92       	push	r0
	{
		/* Create the queues used by the com test task. */
		xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     2b6:	84 2f       	mov	r24, r20
     2b8:	61 e0       	ldi	r22, 0x01	; 1
     2ba:	40 e0       	ldi	r20, 0x00	; 0
     2bc:	0e 94 ef 09 	call	0x13de	; 0x13de <xQueueGenericCreate>
     2c0:	90 93 b9 02 	sts	0x02B9, r25
     2c4:	80 93 b8 02 	sts	0x02B8, r24
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     2c8:	8d 2d       	mov	r24, r13
     2ca:	61 e0       	ldi	r22, 0x01	; 1
     2cc:	40 e0       	ldi	r20, 0x00	; 0
     2ce:	0e 94 ef 09 	call	0x13de	; 0x13de <xQueueGenericCreate>
     2d2:	90 93 bb 02 	sts	0x02BB, r25
     2d6:	80 93 ba 02 	sts	0x02BA, r24
		 */
		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( uint32_t ) 1;


		/* Set the baud rate. */	
		UBRR0 = ulBaudRateCounter;
     2da:	83 e0       	ldi	r24, 0x03	; 3
     2dc:	ee 0c       	add	r14, r14
     2de:	ff 1c       	adc	r15, r15
     2e0:	00 1f       	adc	r16, r16
     2e2:	11 1f       	adc	r17, r17
     2e4:	8a 95       	dec	r24
     2e6:	d1 f7       	brne	.-12     	; 0x2dc <xSerialPortInitMinimal+0x3c>
     2e8:	60 e0       	ldi	r22, 0x00	; 0
     2ea:	74 e2       	ldi	r23, 0x24	; 36
     2ec:	84 ef       	ldi	r24, 0xF4	; 244
     2ee:	90 e0       	ldi	r25, 0x00	; 0
     2f0:	a8 01       	movw	r20, r16
     2f2:	97 01       	movw	r18, r14
     2f4:	0e 94 1e 12 	call	0x243c	; 0x243c <__udivmodsi4>
     2f8:	21 50       	subi	r18, 0x01	; 1
     2fa:	30 40       	sbci	r19, 0x00	; 0
     2fc:	40 40       	sbci	r20, 0x00	; 0
     2fe:	50 40       	sbci	r21, 0x00	; 0
     300:	30 93 c5 00 	sts	0x00C5, r19
     304:	20 93 c4 00 	sts	0x00C4, r18

		/* Choose the double speed mode */
		ucByte = UCSR0A;
     308:	e0 ec       	ldi	r30, 0xC0	; 192
     30a:	f0 e0       	ldi	r31, 0x00	; 0
     30c:	80 81       	ld	r24, Z
		ucByte |= ( serDOUBLE_SPEED );
     30e:	82 60       	ori	r24, 0x02	; 2
		UCSR0A = ucByte;
     310:	80 83       	st	Z, r24

		/* Enable the Rx interrupt.  The Tx interrupt will get enabled
		later. Also enable the Rx and Tx. */
		UCSR0B = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
     312:	88 e9       	ldi	r24, 0x98	; 152
     314:	80 93 c1 00 	sts	0x00C1, r24

		/* Set the data bits to 8, 1 stop bit, no parity (8n1). */
		UCSR0C = ( serEIGHT_DATA_BITS );
     318:	86 e0       	ldi	r24, 0x06	; 6
     31a:	80 93 c2 00 	sts	0x00C2, r24
	}
	portEXIT_CRITICAL();
     31e:	0f 90       	pop	r0
     320:	0f be       	out	0x3f, r0	; 63
	
	/* Unlike other ports, this serial code does not allow for more than one
	com port.  We therefore don't return a pointer to a port structure and can
	instead just return NULL. */
	return NULL;
}
     322:	80 e0       	ldi	r24, 0x00	; 0
     324:	90 e0       	ldi	r25, 0x00	; 0
     326:	1f 91       	pop	r17
     328:	0f 91       	pop	r16
     32a:	ff 90       	pop	r15
     32c:	ef 90       	pop	r14
     32e:	df 90       	pop	r13
     330:	08 95       	ret

00000332 <xAreRegTestTasksStillRunning>:
	xTaskCreate( prvRegisterCheck2, "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
}
/*-----------------------------------------------------------*/

portBASE_TYPE xAreRegTestTasksStillRunning( void )
{
     332:	90 e0       	ldi	r25, 0x00	; 0
     334:	80 91 bc 02 	lds	r24, 0x02BC
     338:	88 23       	and	r24, r24
     33a:	09 f4       	brne	.+2      	; 0x33e <xAreRegTestTasksStillRunning+0xc>
     33c:	91 e0       	ldi	r25, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     33e:	89 2f       	mov	r24, r25
     340:	08 95       	ret

00000342 <prvRegisterCheck1>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	5"		);
     342:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r0,		r31"	);
     344:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	6"		);
     346:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r1,		r31"	);
     348:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	7"		);
     34a:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r2,		r31"	);
     34c:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	8"		);
     34e:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r3,		r31"	);
     350:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	9"		);
     352:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r4,		r31"	);
     354:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	10"		);
     356:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r5,		r31"	);
     358:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	11"		);
     35a:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r6,		r31"	);
     35c:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	12"		);
     35e:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r7,		r31"	);
     360:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	13"		);
     362:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r8,		r31"	);
     364:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	14"		);
     366:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r9,		r31"	);
     368:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	15"		);
     36a:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r10,	r31"	);
     36c:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	16"		);
     36e:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r11,	r31"	);
     370:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	17"		);
     372:	f1 e1       	ldi	r31, 0x11	; 17
		asm( 	"MOV	r12,	r31"	);
     374:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	18"		);
     376:	f2 e1       	ldi	r31, 0x12	; 18
		asm( 	"MOV	r13,	r31"	);
     378:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	19"		);
     37a:	f3 e1       	ldi	r31, 0x13	; 19
		asm( 	"MOV	r14,	r31"	);
     37c:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	20"		);
     37e:	f4 e1       	ldi	r31, 0x14	; 20
		asm( 	"MOV	r15,	r31"	);
     380:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	21"		);
     382:	05 e1       	ldi	r16, 0x15	; 21
		asm(	"LDI	r17,	22"		);
     384:	16 e1       	ldi	r17, 0x16	; 22
		asm(	"LDI	r18,	23"		);
     386:	27 e1       	ldi	r18, 0x17	; 23
		asm(	"LDI	r19,	24"		);
     388:	38 e1       	ldi	r19, 0x18	; 24
		asm(	"LDI	r20,	25"		);
     38a:	49 e1       	ldi	r20, 0x19	; 25
		asm(	"LDI	r21,	26"		);
     38c:	5a e1       	ldi	r21, 0x1A	; 26
		asm(	"LDI	r22,	27"		);
     38e:	6b e1       	ldi	r22, 0x1B	; 27
		asm(	"LDI	r23,	28"		);
     390:	7c e1       	ldi	r23, 0x1C	; 28
		asm(	"LDI	r24,	29"		);
     392:	8d e1       	ldi	r24, 0x1D	; 29
		asm(	"LDI	r25,	30"		);
     394:	9e e1       	ldi	r25, 0x1E	; 30
		asm(	"LDI	r26,	31"		);
     396:	af e1       	ldi	r26, 0x1F	; 31
		asm(	"LDI	r27,	32"		);
     398:	b0 e2       	ldi	r27, 0x20	; 32
		asm(	"LDI	r30,	33"		);
     39a:	e1 e2       	ldi	r30, 0x21	; 33

		asm(	"LDI	r31,	5"			);
     39c:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r0"			);
     39e:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     3a0:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	6"			);
     3a4:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r1"			);
     3a6:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     3a8:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	7"			);
     3ac:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r2"			);
     3ae:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     3b0:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	8"			);
     3b4:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r3"			);
     3b6:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     3b8:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	9"			);
     3bc:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r4"			);
     3be:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     3c0:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	10"			);
     3c4:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r5"			);
     3c6:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     3c8:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	11"			);
     3cc:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r6"			);
     3ce:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     3d0:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	12"			);
     3d4:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r7"			);
     3d6:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     3d8:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	13"			);
     3dc:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r8"			);
     3de:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     3e0:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	14"			);
     3e4:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r9"			);
     3e6:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     3e8:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	15"			);
     3ec:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r10"		);
     3ee:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     3f0:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	16"			);
     3f4:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r11"		);
     3f6:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     3f8:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	17"			);
     3fc:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r12"		);
     3fe:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     400:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	18"			);
     404:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r13"		);
     406:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     408:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	19"			);
     40c:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r14"		);
     40e:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     410:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	20"			);
     414:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r15"		);
     416:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     418:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	21"			);
     41c:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r16"		);
     41e:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     420:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	22"			);
     424:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r17"		);
     426:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     428:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	23"			);
     42c:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r18"		);
     42e:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     430:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	24"			);
     434:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r19"		);
     436:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     438:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	25"			);
     43c:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r20"		);
     43e:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     440:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	26"			);
     444:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r21"		);
     446:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     448:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	27"			);
     44c:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r22"		);
     44e:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     450:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	28"			);
     454:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r23"		);
     456:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     458:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	29"			);
     45c:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r24"		);
     45e:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     460:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	30"			);
     464:	fe e1       	ldi	r31, 0x1E	; 30
		asm(	"CPSE	r31,	r25"		);
     466:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     468:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	31"			);
     46c:	ff e1       	ldi	r31, 0x1F	; 31
		asm(	"CPSE	r31,	r26"		);
     46e:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     470:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	32"			);
     474:	f0 e2       	ldi	r31, 0x20	; 32
		asm(	"CPSE	r31,	r27"		);
     476:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     478:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	33"			);
     47c:	f1 e2       	ldi	r31, 0x21	; 33
		asm(	"CPSE	r31,	r30"		);
     47e:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     480:	00 92 bc 02 	sts	0x02BC, r0
     484:	5e cf       	rjmp	.-324    	; 0x342 <prvRegisterCheck1>

00000486 <prvRegisterCheck2>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	1"		);
     486:	f1 e0       	ldi	r31, 0x01	; 1
		asm( 	"MOV	r0,		r31"	);
     488:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	2"		);
     48a:	f2 e0       	ldi	r31, 0x02	; 2
		asm( 	"MOV	r1,		r31"	);
     48c:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	3"		);
     48e:	f3 e0       	ldi	r31, 0x03	; 3
		asm( 	"MOV	r2,		r31"	);
     490:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	4"		);
     492:	f4 e0       	ldi	r31, 0x04	; 4
		asm( 	"MOV	r3,		r31"	);
     494:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	5"		);
     496:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r4,		r31"	);
     498:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	6"		);
     49a:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r5,		r31"	);
     49c:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	7"		);
     49e:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r6,		r31"	);
     4a0:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	8"		);
     4a2:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r7,		r31"	);
     4a4:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	9"		);
     4a6:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r8,		r31"	);
     4a8:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	10"		);
     4aa:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r9,		r31"	);
     4ac:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	11"		);
     4ae:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r10,	r31"	);
     4b0:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	12"		);
     4b2:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r11,	r31"	);
     4b4:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	13"		);
     4b6:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r12,	r31"	);
     4b8:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	14"		);
     4ba:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r13,	r31"	);
     4bc:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	15"		);
     4be:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r14,	r31"	);
     4c0:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	16"		);
     4c2:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r15,	r31"	);
     4c4:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	17"		);
     4c6:	01 e1       	ldi	r16, 0x11	; 17
		asm(	"LDI	r17,	18"		);
     4c8:	12 e1       	ldi	r17, 0x12	; 18
		asm(	"LDI	r18,	19"		);
     4ca:	23 e1       	ldi	r18, 0x13	; 19
		asm(	"LDI	r19,	20"		);
     4cc:	34 e1       	ldi	r19, 0x14	; 20
		asm(	"LDI	r20,	21"		);
     4ce:	45 e1       	ldi	r20, 0x15	; 21
		asm(	"LDI	r21,	22"		);
     4d0:	56 e1       	ldi	r21, 0x16	; 22
		asm(	"LDI	r22,	23"		);
     4d2:	67 e1       	ldi	r22, 0x17	; 23
		asm(	"LDI	r23,	24"		);
     4d4:	78 e1       	ldi	r23, 0x18	; 24
		asm(	"LDI	r24,	25"		);
     4d6:	89 e1       	ldi	r24, 0x19	; 25
		asm(	"LDI	r25,	26"		);
     4d8:	9a e1       	ldi	r25, 0x1A	; 26
		asm(	"LDI	r26,	27"		);
     4da:	ab e1       	ldi	r26, 0x1B	; 27
		asm(	"LDI	r27,	28"		);
     4dc:	bc e1       	ldi	r27, 0x1C	; 28
		asm(	"LDI	r30,	29"		);
     4de:	ed e1       	ldi	r30, 0x1D	; 29

		asm(	"LDI	r31,	1"			);
     4e0:	f1 e0       	ldi	r31, 0x01	; 1
		asm(	"CPSE	r31,	r0"			);
     4e2:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     4e4:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	2"			);
     4e8:	f2 e0       	ldi	r31, 0x02	; 2
		asm(	"CPSE	r31,	r1"			);
     4ea:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     4ec:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	3"			);
     4f0:	f3 e0       	ldi	r31, 0x03	; 3
		asm(	"CPSE	r31,	r2"			);
     4f2:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     4f4:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	4"			);
     4f8:	f4 e0       	ldi	r31, 0x04	; 4
		asm(	"CPSE	r31,	r3"			);
     4fa:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     4fc:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	5"			);
     500:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r4"			);
     502:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     504:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	6"			);
     508:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r5"			);
     50a:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     50c:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	7"			);
     510:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r6"			);
     512:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     514:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	8"			);
     518:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r7"			);
     51a:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     51c:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	9"			);
     520:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r8"			);
     522:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     524:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	10"			);
     528:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r9"			);
     52a:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     52c:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	11"			);
     530:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r10"		);
     532:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     534:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	12"			);
     538:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r11"		);
     53a:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     53c:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	13"			);
     540:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r12"		);
     542:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     544:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	14"			);
     548:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r13"		);
     54a:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     54c:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	15"			);
     550:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r14"		);
     552:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     554:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	16"			);
     558:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r15"		);
     55a:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     55c:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	17"			);
     560:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r16"		);
     562:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     564:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	18"			);
     568:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r17"		);
     56a:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     56c:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	19"			);
     570:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r18"		);
     572:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     574:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	20"			);
     578:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r19"		);
     57a:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     57c:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	21"			);
     580:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r20"		);
     582:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     584:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	22"			);
     588:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r21"		);
     58a:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     58c:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	23"			);
     590:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r22"		);
     592:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     594:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	24"			);
     598:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r23"		);
     59a:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     59c:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	25"			);
     5a0:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r24"		);
     5a2:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     5a4:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	26"			);
     5a8:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r25"		);
     5aa:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     5ac:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	27"			);
     5b0:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r26"		);
     5b2:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     5b4:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	28"			);
     5b8:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r27"		);
     5ba:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     5bc:	00 92 bc 02 	sts	0x02BC, r0
		asm(	"LDI	r31,	29"			);
     5c0:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r30"		);
     5c2:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     5c4:	00 92 bc 02 	sts	0x02BC, r0
     5c8:	5e cf       	rjmp	.-324    	; 0x486 <prvRegisterCheck2>

000005ca <vStartRegTestTasks>:
portBASE_TYPE xRegTestError = pdFALSE;

/*-----------------------------------------------------------*/

void vStartRegTestTasks( void )
{
     5ca:	ef 92       	push	r14
     5cc:	ff 92       	push	r15
     5ce:	0f 93       	push	r16
	xTaskCreate( prvRegisterCheck1, "Reg1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     5d0:	81 ea       	ldi	r24, 0xA1	; 161
     5d2:	91 e0       	ldi	r25, 0x01	; 1
     5d4:	60 e0       	ldi	r22, 0x00	; 0
     5d6:	72 e0       	ldi	r23, 0x02	; 2
     5d8:	45 e5       	ldi	r20, 0x55	; 85
     5da:	50 e0       	ldi	r21, 0x00	; 0
     5dc:	20 e0       	ldi	r18, 0x00	; 0
     5de:	30 e0       	ldi	r19, 0x00	; 0
     5e0:	00 e0       	ldi	r16, 0x00	; 0
     5e2:	ee 24       	eor	r14, r14
     5e4:	ff 24       	eor	r15, r15
     5e6:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <xTaskCreate>
	xTaskCreate( prvRegisterCheck2, "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     5ea:	83 e4       	ldi	r24, 0x43	; 67
     5ec:	92 e0       	ldi	r25, 0x02	; 2
     5ee:	65 e0       	ldi	r22, 0x05	; 5
     5f0:	72 e0       	ldi	r23, 0x02	; 2
     5f2:	45 e5       	ldi	r20, 0x55	; 85
     5f4:	50 e0       	ldi	r21, 0x00	; 0
     5f6:	20 e0       	ldi	r18, 0x00	; 0
     5f8:	30 e0       	ldi	r19, 0x00	; 0
     5fa:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <xTaskCreate>
}
     5fe:	0f 91       	pop	r16
     600:	ff 90       	pop	r15
     602:	ef 90       	pop	r14
     604:	08 95       	ret

00000606 <vParTestInitialise>:

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
	ucCurrentOutputValue = partstALL_OUTPUTS_OFF;
     606:	8f e0       	ldi	r24, 0x0F	; 15
     608:	80 93 a2 02 	sts	0x02A2, r24

	/* Set port B direction to outputs.  Start with all output off. */
	DDRB = partstLEDS_OUTPUT;
     60c:	80 ef       	ldi	r24, 0xF0	; 240
     60e:	84 b9       	out	0x04, r24	; 4
	PORTB &= ucCurrentOutputValue;
     610:	95 b1       	in	r25, 0x05	; 5
     612:	80 91 a2 02 	lds	r24, 0x02A2
     616:	89 23       	and	r24, r25
     618:	85 b9       	out	0x05, r24	; 5
}
     61a:	08 95       	ret

0000061c <vParTestToggleLED>:
	}
}
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
     61c:	0f 93       	push	r16
     61e:	1f 93       	push	r17
     620:	98 2f       	mov	r25, r24
unsigned char ucBit;

	if(( uxLED <= partstMAX_OUTPUT_LED ) && ( uxLED >= partstMIN_OUTPUT_LED ))
     622:	84 50       	subi	r24, 0x04	; 4
     624:	84 30       	cpi	r24, 0x04	; 4
     626:	70 f4       	brcc	.+28     	; 0x644 <vParTestToggleLED+0x28>
	{
		ucBit = ( ( unsigned char ) 1 ) << uxLED;
     628:	01 e0       	ldi	r16, 0x01	; 1
     62a:	10 e0       	ldi	r17, 0x00	; 0
     62c:	02 c0       	rjmp	.+4      	; 0x632 <vParTestToggleLED+0x16>
     62e:	00 0f       	add	r16, r16
     630:	11 1f       	adc	r17, r17
     632:	9a 95       	dec	r25
     634:	e2 f7       	brpl	.-8      	; 0x62e <vParTestToggleLED+0x12>

		vTaskSuspendAll();
     636:	02 d7       	rcall	.+3588   	; 0x143c <vTaskSuspendAll>
     638:	03 b9       	out	0x03, r16	; 3
		{

			PINB = ucBit;
     63a:	85 b1       	in	r24, 0x05	; 5
			ucCurrentOutputValue = PORTB;
     63c:	80 93 a2 02 	sts	0x02A2, r24
     640:	0e 94 f3 0b 	call	0x17e6	; 0x17e6 <xTaskResumeAll>
		}
		xTaskResumeAll();			
     644:	1f 91       	pop	r17
	}
}
     646:	0f 91       	pop	r16
     648:	08 95       	ret

0000064a <vParTestSetLED>:
	PORTB &= ucCurrentOutputValue;
}
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     64a:	0f 93       	push	r16
     64c:	1f 93       	push	r17
     64e:	28 2f       	mov	r18, r24
     650:	06 2f       	mov	r16, r22
unsigned char ucBit = ( unsigned char ) 1;

	if(( uxLED <= partstMAX_OUTPUT_LED ) && ( uxLED >= partstMIN_OUTPUT_LED ))
     652:	84 50       	subi	r24, 0x04	; 4
     654:	84 30       	cpi	r24, 0x04	; 4
     656:	10 f5       	brcc	.+68     	; 0x69c <vParTestSetLED+0x52>
	{
		ucBit <<= uxLED;	
     658:	81 e0       	ldi	r24, 0x01	; 1
     65a:	90 e0       	ldi	r25, 0x00	; 0
     65c:	02 c0       	rjmp	.+4      	; 0x662 <vParTestSetLED+0x18>
     65e:	88 0f       	add	r24, r24
     660:	99 1f       	adc	r25, r25
     662:	2a 95       	dec	r18
     664:	e2 f7       	brpl	.-8      	; 0x65e <vParTestSetLED+0x14>
     666:	18 2f       	mov	r17, r24

		vTaskSuspendAll();
     668:	e9 d6       	rcall	.+3538   	; 0x143c <vTaskSuspendAll>
     66a:	00 23       	and	r16, r16
		{
			if( xValue == pdFALSE )
     66c:	59 f4       	brne	.+22     	; 0x684 <vParTestSetLED+0x3a>
     66e:	80 91 a2 02 	lds	r24, 0x02A2
			{
				ucBit ^= ( unsigned char ) 0xff;
				ucCurrentOutputValue &= ucBit;
     672:	10 95       	com	r17
     674:	18 23       	and	r17, r24
     676:	10 93 a2 02 	sts	0x02A2, r17
     67a:	95 b1       	in	r25, 0x05	; 5
				PORTB &= ucCurrentOutputValue;
     67c:	80 91 a2 02 	lds	r24, 0x02A2
     680:	89 23       	and	r24, r25
     682:	09 c0       	rjmp	.+18     	; 0x696 <vParTestSetLED+0x4c>
     684:	80 91 a2 02 	lds	r24, 0x02A2
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     688:	18 2b       	or	r17, r24
     68a:	10 93 a2 02 	sts	0x02A2, r17
     68e:	95 b1       	in	r25, 0x05	; 5
				PORTB |= ucCurrentOutputValue;
     690:	80 91 a2 02 	lds	r24, 0x02A2
     694:	89 2b       	or	r24, r25
     696:	85 b9       	out	0x05, r24	; 5
     698:	0e 94 f3 0b 	call	0x17e6	; 0x17e6 <xTaskResumeAll>
			}
		}
		xTaskResumeAll();
     69c:	1f 91       	pop	r17
	}
}
     69e:	0f 91       	pop	r16
     6a0:	08 95       	ret

000006a2 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     6a2:	fc 01       	movw	r30, r24
	unsigned portSHORT usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     6a4:	91 e1       	ldi	r25, 0x11	; 17
     6a6:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     6a8:	22 e2       	ldi	r18, 0x22	; 34
     6aa:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     6ac:	83 e3       	ldi	r24, 0x33	; 51
     6ae:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     6b0:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     6b2:	72 93       	st	-Z, r23
	pxTopOfStack--;

	*pxTopOfStack = 0;
     6b4:	12 92       	st	-Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     6b6:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     6b8:	80 e8       	ldi	r24, 0x80	; 128
     6ba:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* If we have an ATmega2560, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
     6bc:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
     6be:	12 92       	st	-Z, r1
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     6c0:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     6c2:	82 e0       	ldi	r24, 0x02	; 2
     6c4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     6c6:	83 e0       	ldi	r24, 0x03	; 3
     6c8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     6ca:	84 e0       	ldi	r24, 0x04	; 4
     6cc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     6ce:	85 e0       	ldi	r24, 0x05	; 5
     6d0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     6d2:	86 e0       	ldi	r24, 0x06	; 6
     6d4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     6d6:	87 e0       	ldi	r24, 0x07	; 7
     6d8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     6da:	88 e0       	ldi	r24, 0x08	; 8
     6dc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     6de:	89 e0       	ldi	r24, 0x09	; 9
     6e0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     6e2:	80 e1       	ldi	r24, 0x10	; 16
     6e4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     6e6:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     6e8:	82 e1       	ldi	r24, 0x12	; 18
     6ea:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     6ec:	83 e1       	ldi	r24, 0x13	; 19
     6ee:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     6f0:	84 e1       	ldi	r24, 0x14	; 20
     6f2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     6f4:	85 e1       	ldi	r24, 0x15	; 21
     6f6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     6f8:	86 e1       	ldi	r24, 0x16	; 22
     6fa:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     6fc:	87 e1       	ldi	r24, 0x17	; 23
     6fe:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     700:	88 e1       	ldi	r24, 0x18	; 24
     702:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     704:	89 e1       	ldi	r24, 0x19	; 25
     706:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     708:	80 e2       	ldi	r24, 0x20	; 32
     70a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     70c:	81 e2       	ldi	r24, 0x21	; 33
     70e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     710:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     712:	83 e2       	ldi	r24, 0x23	; 35
     714:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned portSHORT ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     716:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
     718:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     71a:	86 e2       	ldi	r24, 0x26	; 38
     71c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     71e:	87 e2       	ldi	r24, 0x27	; 39
     720:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     722:	88 e2       	ldi	r24, 0x28	; 40
     724:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     726:	89 e2       	ldi	r24, 0x29	; 41
     728:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     72a:	80 e3       	ldi	r24, 0x30	; 48
     72c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x31;	/* R31 */
     72e:	81 e3       	ldi	r24, 0x31	; 49
     730:	82 93       	st	-Z, r24
     732:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     734:	cf 01       	movw	r24, r30
     736:	08 95       	ret

00000738 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     738:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     73c:	89 ef       	ldi	r24, 0xF9	; 249
     73e:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH_TCCR1A;
	TCCR1A = ucLowByte;
     742:	10 92 80 00 	sts	0x0080, r1
	ucLowByte = portCLEAR_COUNTER_ON_MATCH_TCCR1B | portPRESCALE_64;
	TCCR1B = ucLowByte;
     746:	8b e0       	ldi	r24, 0x0B	; 11
     748:	80 93 81 00 	sts	0x0081, r24


	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     74c:	ef e6       	ldi	r30, 0x6F	; 111
     74e:	f0 e0       	ldi	r31, 0x00	; 0
     750:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     752:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     754:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     756:	a0 91 43 20 	lds	r26, 0x2043
     75a:	b0 91 44 20 	lds	r27, 0x2044
     75e:	cd 91       	ld	r28, X+
     760:	cd bf       	out	0x3d, r28	; 61
     762:	dd 91       	ld	r29, X+
     764:	de bf       	out	0x3e, r29	; 62
     766:	ff 91       	pop	r31
     768:	ef 91       	pop	r30
     76a:	df 91       	pop	r29
     76c:	cf 91       	pop	r28
     76e:	bf 91       	pop	r27
     770:	af 91       	pop	r26
     772:	9f 91       	pop	r25
     774:	8f 91       	pop	r24
     776:	7f 91       	pop	r23
     778:	6f 91       	pop	r22
     77a:	5f 91       	pop	r21
     77c:	4f 91       	pop	r20
     77e:	3f 91       	pop	r19
     780:	2f 91       	pop	r18
     782:	1f 91       	pop	r17
     784:	0f 91       	pop	r16
     786:	ff 90       	pop	r15
     788:	ef 90       	pop	r14
     78a:	df 90       	pop	r13
     78c:	cf 90       	pop	r12
     78e:	bf 90       	pop	r11
     790:	af 90       	pop	r10
     792:	9f 90       	pop	r9
     794:	8f 90       	pop	r8
     796:	7f 90       	pop	r7
     798:	6f 90       	pop	r6
     79a:	5f 90       	pop	r5
     79c:	4f 90       	pop	r4
     79e:	3f 90       	pop	r3
     7a0:	2f 90       	pop	r2
     7a2:	1f 90       	pop	r1
     7a4:	0f 90       	pop	r0
     7a6:	0c be       	out	0x3c, r0	; 60
     7a8:	0f 90       	pop	r0
     7aa:	0b be       	out	0x3b, r0	; 59
     7ac:	0f 90       	pop	r0
     7ae:	0f be       	out	0x3f, r0	; 63
     7b0:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     7b2:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     7b4:	81 e0       	ldi	r24, 0x01	; 1
     7b6:	08 95       	ret

000007b8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     7b8:	0f 92       	push	r0
     7ba:	0f b6       	in	r0, 0x3f	; 63
     7bc:	f8 94       	cli
     7be:	0f 92       	push	r0
     7c0:	0b b6       	in	r0, 0x3b	; 59
     7c2:	0f 92       	push	r0
     7c4:	0c b6       	in	r0, 0x3c	; 60
     7c6:	0f 92       	push	r0
     7c8:	1f 92       	push	r1
     7ca:	11 24       	eor	r1, r1
     7cc:	2f 92       	push	r2
     7ce:	3f 92       	push	r3
     7d0:	4f 92       	push	r4
     7d2:	5f 92       	push	r5
     7d4:	6f 92       	push	r6
     7d6:	7f 92       	push	r7
     7d8:	8f 92       	push	r8
     7da:	9f 92       	push	r9
     7dc:	af 92       	push	r10
     7de:	bf 92       	push	r11
     7e0:	cf 92       	push	r12
     7e2:	df 92       	push	r13
     7e4:	ef 92       	push	r14
     7e6:	ff 92       	push	r15
     7e8:	0f 93       	push	r16
     7ea:	1f 93       	push	r17
     7ec:	2f 93       	push	r18
     7ee:	3f 93       	push	r19
     7f0:	4f 93       	push	r20
     7f2:	5f 93       	push	r21
     7f4:	6f 93       	push	r22
     7f6:	7f 93       	push	r23
     7f8:	8f 93       	push	r24
     7fa:	9f 93       	push	r25
     7fc:	af 93       	push	r26
     7fe:	bf 93       	push	r27
     800:	cf 93       	push	r28
     802:	df 93       	push	r29
     804:	ef 93       	push	r30
     806:	ff 93       	push	r31
     808:	a0 91 43 20 	lds	r26, 0x2043
     80c:	b0 91 44 20 	lds	r27, 0x2044
     810:	0d b6       	in	r0, 0x3d	; 61
     812:	0d 92       	st	X+, r0
     814:	0e b6       	in	r0, 0x3e	; 62
     816:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     818:	12 d7       	rcall	.+3620   	; 0x163e <xTaskIncrementTick>
     81a:	88 23       	and	r24, r24
     81c:	09 f0       	breq	.+2      	; 0x820 <vPortYieldFromTick+0x68>
     81e:	82 d6       	rcall	.+3332   	; 0x1524 <vTaskSwitchContext>
	{
		vTaskSwitchContext();
     820:	a0 91 43 20 	lds	r26, 0x2043
	}
	portRESTORE_CONTEXT();
     824:	b0 91 44 20 	lds	r27, 0x2044
     828:	cd 91       	ld	r28, X+
     82a:	cd bf       	out	0x3d, r28	; 61
     82c:	dd 91       	ld	r29, X+
     82e:	de bf       	out	0x3e, r29	; 62
     830:	ff 91       	pop	r31
     832:	ef 91       	pop	r30
     834:	df 91       	pop	r29
     836:	cf 91       	pop	r28
     838:	bf 91       	pop	r27
     83a:	af 91       	pop	r26
     83c:	9f 91       	pop	r25
     83e:	8f 91       	pop	r24
     840:	7f 91       	pop	r23
     842:	6f 91       	pop	r22
     844:	5f 91       	pop	r21
     846:	4f 91       	pop	r20
     848:	3f 91       	pop	r19
     84a:	2f 91       	pop	r18
     84c:	1f 91       	pop	r17
     84e:	0f 91       	pop	r16
     850:	ff 90       	pop	r15
     852:	ef 90       	pop	r14
     854:	df 90       	pop	r13
     856:	cf 90       	pop	r12
     858:	bf 90       	pop	r11
     85a:	af 90       	pop	r10
     85c:	9f 90       	pop	r9
     85e:	8f 90       	pop	r8
     860:	7f 90       	pop	r7
     862:	6f 90       	pop	r6
     864:	5f 90       	pop	r5
     866:	4f 90       	pop	r4
     868:	3f 90       	pop	r3
     86a:	2f 90       	pop	r2
     86c:	1f 90       	pop	r1
     86e:	0f 90       	pop	r0
     870:	0c be       	out	0x3c, r0	; 60
     872:	0f 90       	pop	r0
     874:	0b be       	out	0x3b, r0	; 59
     876:	0f 90       	pop	r0
     878:	0f be       	out	0x3f, r0	; 63
     87a:	0f 90       	pop	r0
     87c:	08 95       	ret

0000087e <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	ISR(TIMER1_COMPA_vect) __attribute__ ( ( signal, naked ) );
	ISR(TIMER1_COMPA_vect)
	{
		vPortYieldFromTick();
     87e:	9c df       	rcall	.-200    	; 0x7b8 <vPortYieldFromTick>
     880:	18 95       	reti

00000882 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     882:	0f 92       	push	r0
     884:	0f b6       	in	r0, 0x3f	; 63
     886:	f8 94       	cli
     888:	0f 92       	push	r0
     88a:	0b b6       	in	r0, 0x3b	; 59
     88c:	0f 92       	push	r0
     88e:	0c b6       	in	r0, 0x3c	; 60
     890:	0f 92       	push	r0
     892:	1f 92       	push	r1
     894:	11 24       	eor	r1, r1
     896:	2f 92       	push	r2
     898:	3f 92       	push	r3
     89a:	4f 92       	push	r4
     89c:	5f 92       	push	r5
     89e:	6f 92       	push	r6
     8a0:	7f 92       	push	r7
     8a2:	8f 92       	push	r8
     8a4:	9f 92       	push	r9
     8a6:	af 92       	push	r10
     8a8:	bf 92       	push	r11
     8aa:	cf 92       	push	r12
     8ac:	df 92       	push	r13
     8ae:	ef 92       	push	r14
     8b0:	ff 92       	push	r15
     8b2:	0f 93       	push	r16
     8b4:	1f 93       	push	r17
     8b6:	2f 93       	push	r18
     8b8:	3f 93       	push	r19
     8ba:	4f 93       	push	r20
     8bc:	5f 93       	push	r21
     8be:	6f 93       	push	r22
     8c0:	7f 93       	push	r23
     8c2:	8f 93       	push	r24
     8c4:	9f 93       	push	r25
     8c6:	af 93       	push	r26
     8c8:	bf 93       	push	r27
     8ca:	cf 93       	push	r28
     8cc:	df 93       	push	r29
     8ce:	ef 93       	push	r30
     8d0:	ff 93       	push	r31
     8d2:	a0 91 43 20 	lds	r26, 0x2043
     8d6:	b0 91 44 20 	lds	r27, 0x2044
     8da:	0d b6       	in	r0, 0x3d	; 61
     8dc:	0d 92       	st	X+, r0
     8de:	0e b6       	in	r0, 0x3e	; 62
     8e0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     8e2:	20 d6       	rcall	.+3136   	; 0x1524 <vTaskSwitchContext>
     8e4:	a0 91 43 20 	lds	r26, 0x2043
	portRESTORE_CONTEXT();
     8e8:	b0 91 44 20 	lds	r27, 0x2044
     8ec:	cd 91       	ld	r28, X+
     8ee:	cd bf       	out	0x3d, r28	; 61
     8f0:	dd 91       	ld	r29, X+
     8f2:	de bf       	out	0x3e, r29	; 62
     8f4:	ff 91       	pop	r31
     8f6:	ef 91       	pop	r30
     8f8:	df 91       	pop	r29
     8fa:	cf 91       	pop	r28
     8fc:	bf 91       	pop	r27
     8fe:	af 91       	pop	r26
     900:	9f 91       	pop	r25
     902:	8f 91       	pop	r24
     904:	7f 91       	pop	r23
     906:	6f 91       	pop	r22
     908:	5f 91       	pop	r21
     90a:	4f 91       	pop	r20
     90c:	3f 91       	pop	r19
     90e:	2f 91       	pop	r18
     910:	1f 91       	pop	r17
     912:	0f 91       	pop	r16
     914:	ff 90       	pop	r15
     916:	ef 90       	pop	r14
     918:	df 90       	pop	r13
     91a:	cf 90       	pop	r12
     91c:	bf 90       	pop	r11
     91e:	af 90       	pop	r10
     920:	9f 90       	pop	r9
     922:	8f 90       	pop	r8
     924:	7f 90       	pop	r7
     926:	6f 90       	pop	r6
     928:	5f 90       	pop	r5
     92a:	4f 90       	pop	r4
     92c:	3f 90       	pop	r3
     92e:	2f 90       	pop	r2
     930:	1f 90       	pop	r1
     932:	0f 90       	pop	r0
     934:	0c be       	out	0x3c, r0	; 60
     936:	0f 90       	pop	r0
     938:	0b be       	out	0x3b, r0	; 59
     93a:	0f 90       	pop	r0
     93c:	0f be       	out	0x3f, r0	; 63
     93e:	0f 90       	pop	r0
     940:	08 95       	ret

00000942 <vPortFree>:
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
     942:	89 2b       	or	r24, r25
     944:	41 f0       	breq	.+16     	; 0x956 <vPortFree+0x14>
     946:	6b ea       	ldi	r22, 0xAB	; 171
     948:	70 e0       	ldi	r23, 0x00	; 0
     94a:	80 e0       	ldi	r24, 0x00	; 0
     94c:	90 e0       	ldi	r25, 0x00	; 0
     94e:	4a e0       	ldi	r20, 0x0A	; 10
     950:	52 e0       	ldi	r21, 0x02	; 2
     952:	0c 94 12 11 	jmp	0x2224	; 0x2224 <vAssertCalled>
     956:	08 95       	ret

00000958 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     958:	cf 93       	push	r28
     95a:	df 93       	push	r29
     95c:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     95e:	6e d5       	rcall	.+2780   	; 0x143c <vTaskSuspendAll>
     960:	80 91 bf 02 	lds	r24, 0x02BF
	{
		if( pucAlignedHeap == NULL )
     964:	90 91 c0 02 	lds	r25, 0x02C0
     968:	89 2b       	or	r24, r25
     96a:	31 f4       	brne	.+12     	; 0x978 <pvPortMalloc+0x20>
     96c:	82 ec       	ldi	r24, 0xC2	; 194
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     96e:	92 e0       	ldi	r25, 0x02	; 2
     970:	90 93 c0 02 	sts	0x02C0, r25
     974:	80 93 bf 02 	sts	0x02BF, r24
     978:	20 91 bd 02 	lds	r18, 0x02BD
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     97c:	30 91 be 02 	lds	r19, 0x02BE
     980:	ce 01       	movw	r24, r28
     982:	82 0f       	add	r24, r18
     984:	93 1f       	adc	r25, r19
     986:	4d e1       	ldi	r20, 0x1D	; 29
     988:	8b 34       	cpi	r24, 0x4B	; 75
     98a:	94 07       	cpc	r25, r20
     98c:	70 f4       	brcc	.+28     	; 0x9aa <pvPortMalloc+0x52>
     98e:	28 17       	cp	r18, r24
     990:	39 07       	cpc	r19, r25
     992:	58 f4       	brcc	.+22     	; 0x9aa <pvPortMalloc+0x52>
     994:	c0 91 bf 02 	lds	r28, 0x02BF
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     998:	d0 91 c0 02 	lds	r29, 0x02C0
     99c:	c2 0f       	add	r28, r18
     99e:	d3 1f       	adc	r29, r19
     9a0:	90 93 be 02 	sts	0x02BE, r25
			xNextFreeByte += xWantedSize;
     9a4:	80 93 bd 02 	sts	0x02BD, r24
     9a8:	02 c0       	rjmp	.+4      	; 0x9ae <pvPortMalloc+0x56>
     9aa:	c0 e0       	ldi	r28, 0x00	; 0
     9ac:	d0 e0       	ldi	r29, 0x00	; 0
     9ae:	1b d7       	rcall	.+3638   	; 0x17e6 <xTaskResumeAll>
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     9b0:	ce 01       	movw	r24, r28
     9b2:	df 91       	pop	r29
		}
	}
	#endif

	return pvReturn;
}
     9b4:	cf 91       	pop	r28
     9b6:	08 95       	ret

000009b8 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
     9b8:	ef 92       	push	r14
     9ba:	ff 92       	push	r15
     9bc:	0f 93       	push	r16
     9be:	1f 93       	push	r17
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     9c0:	dc 01       	movw	r26, r24
     9c2:	15 96       	adiw	r26, 0x05	; 5
     9c4:	ed 91       	ld	r30, X+
     9c6:	fc 91       	ld	r31, X
     9c8:	16 97       	sbiw	r26, 0x06	; 6
     9ca:	e6 80       	ldd	r14, Z+6	; 0x06
     9cc:	f7 80       	ldd	r15, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     9ce:	87 01       	movw	r16, r14
     9d0:	04 5f       	subi	r16, 0xF4	; 244
     9d2:	1f 4f       	sbci	r17, 0xFF	; 255
     9d4:	c8 01       	movw	r24, r16
     9d6:	26 d1       	rcall	.+588    	; 0xc24 <uxListRemove>
     9d8:	8a e3       	ldi	r24, 0x3A	; 58
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     9da:	90 e2       	ldi	r25, 0x20	; 32
     9dc:	b8 01       	movw	r22, r16
     9de:	d1 d0       	rcall	.+418    	; 0xb82 <vListInsertEnd>
     9e0:	20 e0       	ldi	r18, 0x00	; 0
     9e2:	e0 91 0d 20 	lds	r30, 0x200D
     9e6:	f0 91 0e 20 	lds	r31, 0x200E
     9ea:	d7 01       	movw	r26, r14
     9ec:	56 96       	adiw	r26, 0x16	; 22
     9ee:	9c 91       	ld	r25, X
     9f0:	86 89       	ldd	r24, Z+22	; 0x16
     9f2:	98 17       	cp	r25, r24
     9f4:	08 f0       	brcs	.+2      	; 0x9f8 <xCoRoutineRemoveFromEventList+0x40>
     9f6:	21 e0       	ldi	r18, 0x01	; 1
     9f8:	82 2f       	mov	r24, r18
     9fa:	1f 91       	pop	r17
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     9fc:	0f 91       	pop	r16
     9fe:	ff 90       	pop	r15
     a00:	ef 90       	pop	r14
     a02:	08 95       	ret

00000a04 <vCoRoutineAddToDelayedList>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
     a04:	0f 93       	push	r16
     a06:	1f 93       	push	r17
     a08:	cf 93       	push	r28
     a0a:	df 93       	push	r29
     a0c:	eb 01       	movw	r28, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     a0e:	00 91 10 20 	lds	r16, 0x2010
     a12:	10 91 11 20 	lds	r17, 0x2011
     a16:	08 0f       	add	r16, r24
     a18:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     a1a:	80 91 0d 20 	lds	r24, 0x200D
     a1e:	90 91 0e 20 	lds	r25, 0x200E
     a22:	02 96       	adiw	r24, 0x02	; 2
     a24:	ff d0       	rcall	.+510    	; 0xc24 <uxListRemove>
     a26:	e0 91 0d 20 	lds	r30, 0x200D

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     a2a:	f0 91 0e 20 	lds	r31, 0x200E
     a2e:	13 83       	std	Z+3, r17	; 0x03
     a30:	02 83       	std	Z+2, r16	; 0x02
     a32:	80 91 10 20 	lds	r24, 0x2010

	if( xTimeToWake < xCoRoutineTickCount )
     a36:	90 91 11 20 	lds	r25, 0x2011
     a3a:	bf 01       	movw	r22, r30
     a3c:	6e 5f       	subi	r22, 0xFE	; 254
     a3e:	7f 4f       	sbci	r23, 0xFF	; 255
     a40:	08 17       	cp	r16, r24
     a42:	19 07       	cpc	r17, r25
     a44:	28 f4       	brcc	.+10     	; 0xa50 <vCoRoutineAddToDelayedList+0x4c>
     a46:	80 91 38 20 	lds	r24, 0x2038
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     a4a:	90 91 39 20 	lds	r25, 0x2039
     a4e:	04 c0       	rjmp	.+8      	; 0xa58 <vCoRoutineAddToDelayedList+0x54>
     a50:	80 91 36 20 	lds	r24, 0x2036
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     a54:	90 91 37 20 	lds	r25, 0x2037
     a58:	b3 d0       	rcall	.+358    	; 0xbc0 <vListInsert>
     a5a:	20 97       	sbiw	r28, 0x00	; 0
     a5c:	41 f0       	breq	.+16     	; 0xa6e <vCoRoutineAddToDelayedList+0x6a>
	}

	if( pxEventList )
     a5e:	60 91 0d 20 	lds	r22, 0x200D
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     a62:	70 91 0e 20 	lds	r23, 0x200E
     a66:	64 5f       	subi	r22, 0xF4	; 244
     a68:	7f 4f       	sbci	r23, 0xFF	; 255
     a6a:	ce 01       	movw	r24, r28
     a6c:	a9 d0       	rcall	.+338    	; 0xbc0 <vListInsert>
     a6e:	df 91       	pop	r29
     a70:	cf 91       	pop	r28
     a72:	1f 91       	pop	r17
	}
}
     a74:	0f 91       	pop	r16
     a76:	08 95       	ret

00000a78 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
     a78:	af 92       	push	r10
     a7a:	bf 92       	push	r11
     a7c:	cf 92       	push	r12
     a7e:	df 92       	push	r13
     a80:	ef 92       	push	r14
     a82:	ff 92       	push	r15
     a84:	0f 93       	push	r16
     a86:	1f 93       	push	r17
     a88:	cf 93       	push	r28
     a8a:	df 93       	push	r29
     a8c:	6c 01       	movw	r12, r24
     a8e:	b6 2e       	mov	r11, r22
     a90:	a4 2e       	mov	r10, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     a92:	8a e1       	ldi	r24, 0x1A	; 26
     a94:	90 e0       	ldi	r25, 0x00	; 0
     a96:	60 df       	rcall	.-320    	; 0x958 <pvPortMalloc>
     a98:	ec 01       	movw	r28, r24
     a9a:	00 97       	sbiw	r24, 0x00	; 0
	if( pxCoRoutine )
     a9c:	11 f4       	brne	.+4      	; 0xaa2 <xCoRoutineCreate+0x2a>
     a9e:	8f ef       	ldi	r24, 0xFF	; 255
     aa0:	51 c0       	rjmp	.+162    	; 0xb44 <xCoRoutineCreate+0xcc>
     aa2:	80 91 0d 20 	lds	r24, 0x200D
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     aa6:	90 91 0e 20 	lds	r25, 0x200E
     aaa:	89 2b       	or	r24, r25
     aac:	f9 f4       	brne	.+62     	; 0xaec <xCoRoutineCreate+0x74>
     aae:	d0 93 0e 20 	sts	0x200E, r29
		{
			pxCurrentCoRoutine = pxCoRoutine;
     ab2:	c0 93 0d 20 	sts	0x200D, r28
     ab6:	82 e1       	ldi	r24, 0x12	; 18
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     ab8:	90 e2       	ldi	r25, 0x20	; 32
     aba:	4f d0       	rcall	.+158    	; 0xb5a <vListInitialise>
     abc:	8b e1       	ldi	r24, 0x1B	; 27
     abe:	90 e2       	ldi	r25, 0x20	; 32
     ac0:	4c d0       	rcall	.+152    	; 0xb5a <vListInitialise>
     ac2:	24 e2       	ldi	r18, 0x24	; 36
     ac4:	e2 2e       	mov	r14, r18
     ac6:	20 e2       	ldi	r18, 0x20	; 32
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     ac8:	f2 2e       	mov	r15, r18
     aca:	c7 01       	movw	r24, r14
     acc:	46 d0       	rcall	.+140    	; 0xb5a <vListInitialise>
     ace:	0d e2       	ldi	r16, 0x2D	; 45
     ad0:	10 e2       	ldi	r17, 0x20	; 32
     ad2:	c8 01       	movw	r24, r16
     ad4:	42 d0       	rcall	.+132    	; 0xb5a <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     ad6:	8a e3       	ldi	r24, 0x3A	; 58
     ad8:	90 e2       	ldi	r25, 0x20	; 32
     ada:	3f d0       	rcall	.+126    	; 0xb5a <vListInitialise>
     adc:	f0 92 37 20 	sts	0x2037, r15
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     ae0:	e0 92 36 20 	sts	0x2036, r14
     ae4:	10 93 39 20 	sts	0x2039, r17

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     ae8:	00 93 38 20 	sts	0x2038, r16
     aec:	eb 2c       	mov	r14, r11
     aee:	bb 20       	and	r11, r11
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     af0:	11 f0       	breq	.+4      	; 0xaf6 <xCoRoutineCreate+0x7e>
     af2:	ee 24       	eor	r14, r14
     af4:	e3 94       	inc	r14
     af6:	19 8e       	std	Y+25, r1	; 0x19
     af8:	18 8e       	std	Y+24, r1	; 0x18
     afa:	ee 8a       	std	Y+22, r14	; 0x16
     afc:	af 8a       	std	Y+23, r10	; 0x17
     afe:	fe 01       	movw	r30, r28
     b00:	c1 92       	st	Z+, r12
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     b02:	d1 92       	st	Z+, r13
     b04:	8f 01       	movw	r16, r30
		pxCoRoutine->uxPriority = uxPriority;
     b06:	cf 01       	movw	r24, r30
		pxCoRoutine->uxIndex = uxIndex;
     b08:	38 d0       	rcall	.+112    	; 0xb7a <vListInitialiseItem>
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     b0a:	ce 01       	movw	r24, r28
     b0c:	0c 96       	adiw	r24, 0x0c	; 12
     b0e:	35 d0       	rcall	.+106    	; 0xb7a <vListInitialiseItem>
     b10:	d9 87       	std	Y+9, r29	; 0x09

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     b12:	c8 87       	std	Y+8, r28	; 0x08
     b14:	db 8b       	std	Y+19, r29	; 0x13
     b16:	ca 8b       	std	Y+18, r28	; 0x12
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     b18:	82 e0       	ldi	r24, 0x02	; 2
     b1a:	90 e0       	ldi	r25, 0x00	; 0
     b1c:	8e 19       	sub	r24, r14
     b1e:	91 09       	sbc	r25, r1

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     b20:	9d 87       	std	Y+13, r25	; 0x0d
     b22:	8c 87       	std	Y+12, r24	; 0x0c
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     b24:	9e 89       	ldd	r25, Y+22	; 0x16
     b26:	80 91 0f 20 	lds	r24, 0x200F

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     b2a:	89 17       	cp	r24, r25
     b2c:	10 f4       	brcc	.+4      	; 0xb32 <xCoRoutineCreate+0xba>
     b2e:	90 93 0f 20 	sts	0x200F, r25
     b32:	89 e0       	ldi	r24, 0x09	; 9

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     b34:	98 9f       	mul	r25, r24
     b36:	c0 01       	movw	r24, r0
     b38:	11 24       	eor	r1, r1
     b3a:	8e 5e       	subi	r24, 0xEE	; 238
     b3c:	9f 4d       	sbci	r25, 0xDF	; 223
     b3e:	b8 01       	movw	r22, r16
     b40:	20 d0       	rcall	.+64     	; 0xb82 <vListInsertEnd>
     b42:	81 e0       	ldi	r24, 0x01	; 1
     b44:	df 91       	pop	r29
     b46:	cf 91       	pop	r28
     b48:	1f 91       	pop	r17
     b4a:	0f 91       	pop	r16
     b4c:	ff 90       	pop	r15
     b4e:	ef 90       	pop	r14
     b50:	df 90       	pop	r13
     b52:	cf 90       	pop	r12
     b54:	bf 90       	pop	r11
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}

	return xReturn;
}
     b56:	af 90       	pop	r10
     b58:	08 95       	ret

00000b5a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     b5a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b5c:	9c 01       	movw	r18, r24
     b5e:	2d 5f       	subi	r18, 0xFD	; 253
     b60:	3f 4f       	sbci	r19, 0xFF	; 255
     b62:	32 83       	std	Z+2, r19	; 0x02
     b64:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     b66:	8f ef       	ldi	r24, 0xFF	; 255
     b68:	9f ef       	ldi	r25, 0xFF	; 255
     b6a:	94 83       	std	Z+4, r25	; 0x04
     b6c:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b6e:	36 83       	std	Z+6, r19	; 0x06
     b70:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b72:	30 87       	std	Z+8, r19	; 0x08
     b74:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     b76:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     b78:	08 95       	ret

00000b7a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     b7a:	fc 01       	movw	r30, r24
     b7c:	11 86       	std	Z+9, r1	; 0x09
     b7e:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     b80:	08 95       	ret

00000b82 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     b82:	ac 01       	movw	r20, r24
ListItem_t * const pxIndex = pxList->pxIndex;
     b84:	fc 01       	movw	r30, r24
     b86:	a1 81       	ldd	r26, Z+1	; 0x01
     b88:	b2 81       	ldd	r27, Z+2	; 0x02
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     b8a:	fb 01       	movw	r30, r22
     b8c:	b3 83       	std	Z+3, r27	; 0x03
     b8e:	a2 83       	std	Z+2, r26	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     b90:	14 96       	adiw	r26, 0x04	; 4
     b92:	8d 91       	ld	r24, X+
     b94:	9c 91       	ld	r25, X
     b96:	15 97       	sbiw	r26, 0x05	; 5
     b98:	95 83       	std	Z+5, r25	; 0x05
     b9a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     b9c:	14 96       	adiw	r26, 0x04	; 4
     b9e:	ed 91       	ld	r30, X+
     ba0:	fc 91       	ld	r31, X
     ba2:	15 97       	sbiw	r26, 0x05	; 5
     ba4:	73 83       	std	Z+3, r23	; 0x03
     ba6:	62 83       	std	Z+2, r22	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     ba8:	15 96       	adiw	r26, 0x05	; 5
     baa:	7c 93       	st	X, r23
     bac:	6e 93       	st	-X, r22
     bae:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     bb0:	fb 01       	movw	r30, r22
     bb2:	51 87       	std	Z+9, r21	; 0x09
     bb4:	40 87       	std	Z+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     bb6:	fa 01       	movw	r30, r20
     bb8:	80 81       	ld	r24, Z
     bba:	8f 5f       	subi	r24, 0xFF	; 255
     bbc:	80 83       	st	Z, r24
}
     bbe:	08 95       	ret

00000bc0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     bc0:	cf 93       	push	r28
     bc2:	df 93       	push	r29
     bc4:	9c 01       	movw	r18, r24
     bc6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     bc8:	48 81       	ld	r20, Y
     bca:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     bcc:	8f ef       	ldi	r24, 0xFF	; 255
     bce:	4f 3f       	cpi	r20, 0xFF	; 255
     bd0:	58 07       	cpc	r21, r24
     bd2:	21 f4       	brne	.+8      	; 0xbdc <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     bd4:	f9 01       	movw	r30, r18
     bd6:	a7 81       	ldd	r26, Z+7	; 0x07
     bd8:	b0 85       	ldd	r27, Z+8	; 0x08
     bda:	0d c0       	rjmp	.+26     	; 0xbf6 <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     bdc:	d9 01       	movw	r26, r18
     bde:	13 96       	adiw	r26, 0x03	; 3
     be0:	12 96       	adiw	r26, 0x02	; 2
     be2:	ed 91       	ld	r30, X+
     be4:	fc 91       	ld	r31, X
     be6:	13 97       	sbiw	r26, 0x03	; 3
     be8:	80 81       	ld	r24, Z
     bea:	91 81       	ldd	r25, Z+1	; 0x01
     bec:	48 17       	cp	r20, r24
     bee:	59 07       	cpc	r21, r25
     bf0:	10 f0       	brcs	.+4      	; 0xbf6 <vListInsert+0x36>
     bf2:	df 01       	movw	r26, r30
     bf4:	f5 cf       	rjmp	.-22     	; 0xbe0 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     bf6:	12 96       	adiw	r26, 0x02	; 2
     bf8:	ed 91       	ld	r30, X+
     bfa:	fc 91       	ld	r31, X
     bfc:	13 97       	sbiw	r26, 0x03	; 3
     bfe:	fb 83       	std	Y+3, r31	; 0x03
     c00:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     c02:	d5 83       	std	Z+5, r29	; 0x05
     c04:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     c06:	bd 83       	std	Y+5, r27	; 0x05
     c08:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     c0a:	13 96       	adiw	r26, 0x03	; 3
     c0c:	dc 93       	st	X, r29
     c0e:	ce 93       	st	-X, r28
     c10:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     c12:	39 87       	std	Y+9, r19	; 0x09
     c14:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     c16:	f9 01       	movw	r30, r18
     c18:	80 81       	ld	r24, Z
     c1a:	8f 5f       	subi	r24, 0xFF	; 255
     c1c:	80 83       	st	Z, r24
}
     c1e:	df 91       	pop	r29
     c20:	cf 91       	pop	r28
     c22:	08 95       	ret

00000c24 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     c24:	cf 93       	push	r28
     c26:	df 93       	push	r29
     c28:	dc 01       	movw	r26, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     c2a:	18 96       	adiw	r26, 0x08	; 8
     c2c:	cd 91       	ld	r28, X+
     c2e:	dc 91       	ld	r29, X
     c30:	19 97       	sbiw	r26, 0x09	; 9

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     c32:	12 96       	adiw	r26, 0x02	; 2
     c34:	4d 91       	ld	r20, X+
     c36:	5c 91       	ld	r21, X
     c38:	13 97       	sbiw	r26, 0x03	; 3
     c3a:	14 96       	adiw	r26, 0x04	; 4
     c3c:	8d 91       	ld	r24, X+
     c3e:	9c 91       	ld	r25, X
     c40:	15 97       	sbiw	r26, 0x05	; 5
     c42:	fa 01       	movw	r30, r20
     c44:	95 83       	std	Z+5, r25	; 0x05
     c46:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     c48:	14 96       	adiw	r26, 0x04	; 4
     c4a:	2d 91       	ld	r18, X+
     c4c:	3c 91       	ld	r19, X
     c4e:	15 97       	sbiw	r26, 0x05	; 5
     c50:	f9 01       	movw	r30, r18
     c52:	53 83       	std	Z+3, r21	; 0x03
     c54:	42 83       	std	Z+2, r20	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     c56:	89 81       	ldd	r24, Y+1	; 0x01
     c58:	9a 81       	ldd	r25, Y+2	; 0x02
     c5a:	8a 17       	cp	r24, r26
     c5c:	9b 07       	cpc	r25, r27
     c5e:	11 f4       	brne	.+4      	; 0xc64 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     c60:	3a 83       	std	Y+2, r19	; 0x02
     c62:	29 83       	std	Y+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     c64:	19 96       	adiw	r26, 0x09	; 9
     c66:	1c 92       	st	X, r1
     c68:	1e 92       	st	-X, r1
     c6a:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
     c6c:	88 81       	ld	r24, Y
     c6e:	81 50       	subi	r24, 0x01	; 1
     c70:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
}
     c72:	df 91       	pop	r29
     c74:	cf 91       	pop	r28
     c76:	08 95       	ret

00000c78 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     c78:	0f 93       	push	r16
     c7a:	1f 93       	push	r17
     c7c:	cf 93       	push	r28
     c7e:	df 93       	push	r29
     c80:	ec 01       	movw	r28, r24
     c82:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     c84:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     c86:	4c 8d       	ldd	r20, Y+28	; 0x1c
     c88:	44 23       	and	r20, r20
     c8a:	c1 f1       	breq	.+112    	; 0xcfc <prvCopyDataToQueue+0x84>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     c8c:	00 23       	and	r16, r16
     c8e:	b1 f4       	brne	.+44     	; 0xcbc <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     c90:	8c 81       	ldd	r24, Y+4	; 0x04
     c92:	9d 81       	ldd	r25, Y+5	; 0x05
     c94:	50 e0       	ldi	r21, 0x00	; 0
     c96:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     c9a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     c9c:	2c 81       	ldd	r18, Y+4	; 0x04
     c9e:	3d 81       	ldd	r19, Y+5	; 0x05
     ca0:	28 0f       	add	r18, r24
     ca2:	31 1d       	adc	r19, r1
     ca4:	3d 83       	std	Y+5, r19	; 0x05
     ca6:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     ca8:	8a 81       	ldd	r24, Y+2	; 0x02
     caa:	9b 81       	ldd	r25, Y+3	; 0x03
     cac:	28 17       	cp	r18, r24
     cae:	39 07       	cpc	r19, r25
     cb0:	28 f1       	brcs	.+74     	; 0xcfc <prvCopyDataToQueue+0x84>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     cb2:	88 81       	ld	r24, Y
     cb4:	99 81       	ldd	r25, Y+1	; 0x01
     cb6:	9d 83       	std	Y+5, r25	; 0x05
     cb8:	8c 83       	std	Y+4, r24	; 0x04
     cba:	20 c0       	rjmp	.+64     	; 0xcfc <prvCopyDataToQueue+0x84>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     cbc:	8e 81       	ldd	r24, Y+6	; 0x06
     cbe:	9f 81       	ldd	r25, Y+7	; 0x07
     cc0:	50 e0       	ldi	r21, 0x00	; 0
     cc2:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     cc6:	8c 8d       	ldd	r24, Y+28	; 0x1c
     cc8:	90 e0       	ldi	r25, 0x00	; 0
     cca:	44 27       	eor	r20, r20
     ccc:	55 27       	eor	r21, r21
     cce:	48 1b       	sub	r20, r24
     cd0:	59 0b       	sbc	r21, r25
     cd2:	8e 81       	ldd	r24, Y+6	; 0x06
     cd4:	9f 81       	ldd	r25, Y+7	; 0x07
     cd6:	84 0f       	add	r24, r20
     cd8:	95 1f       	adc	r25, r21
     cda:	9f 83       	std	Y+7, r25	; 0x07
     cdc:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     cde:	28 81       	ld	r18, Y
     ce0:	39 81       	ldd	r19, Y+1	; 0x01
     ce2:	82 17       	cp	r24, r18
     ce4:	93 07       	cpc	r25, r19
     ce6:	30 f4       	brcc	.+12     	; 0xcf4 <prvCopyDataToQueue+0x7c>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     ce8:	8a 81       	ldd	r24, Y+2	; 0x02
     cea:	9b 81       	ldd	r25, Y+3	; 0x03
     cec:	84 0f       	add	r24, r20
     cee:	95 1f       	adc	r25, r21
     cf0:	9f 83       	std	Y+7, r25	; 0x07
     cf2:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     cf4:	02 30       	cpi	r16, 0x02	; 2
     cf6:	11 f4       	brne	.+4      	; 0xcfc <prvCopyDataToQueue+0x84>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     cf8:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
     cfa:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
     cfc:	1f 5f       	subi	r17, 0xFF	; 255
     cfe:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
     d00:	80 e0       	ldi	r24, 0x00	; 0
     d02:	df 91       	pop	r29
     d04:	cf 91       	pop	r28
     d06:	1f 91       	pop	r17
     d08:	0f 91       	pop	r16
     d0a:	08 95       	ret

00000d0c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     d0c:	fc 01       	movw	r30, r24
     d0e:	56 2f       	mov	r21, r22
     d10:	a7 2f       	mov	r26, r23
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     d12:	24 8d       	ldd	r18, Z+28	; 0x1c
     d14:	22 23       	and	r18, r18
     d16:	b9 f0       	breq	.+46     	; 0xd46 <prvCopyDataFromQueue+0x3a>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     d18:	86 81       	ldd	r24, Z+6	; 0x06
     d1a:	97 81       	ldd	r25, Z+7	; 0x07
     d1c:	82 0f       	add	r24, r18
     d1e:	91 1d       	adc	r25, r1
     d20:	97 83       	std	Z+7, r25	; 0x07
     d22:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     d24:	22 81       	ldd	r18, Z+2	; 0x02
     d26:	33 81       	ldd	r19, Z+3	; 0x03
     d28:	82 17       	cp	r24, r18
     d2a:	93 07       	cpc	r25, r19
     d2c:	20 f0       	brcs	.+8      	; 0xd36 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     d2e:	80 81       	ld	r24, Z
     d30:	91 81       	ldd	r25, Z+1	; 0x01
     d32:	97 83       	std	Z+7, r25	; 0x07
     d34:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     d36:	44 8d       	ldd	r20, Z+28	; 0x1c
     d38:	66 81       	ldd	r22, Z+6	; 0x06
     d3a:	77 81       	ldd	r23, Z+7	; 0x07
     d3c:	85 2f       	mov	r24, r21
     d3e:	9a 2f       	mov	r25, r26
     d40:	50 e0       	ldi	r21, 0x00	; 0
     d42:	0c 94 5b 12 	jmp	0x24b6	; 0x24b6 <memcpy>
     d46:	08 95       	ret

00000d48 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
     d48:	cf 93       	push	r28
     d4a:	df 93       	push	r29
     d4c:	fb 01       	movw	r30, r22
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
     d4e:	ec 01       	movw	r28, r24

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
     d50:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
     d52:	8a 8d       	ldd	r24, Y+26	; 0x1a
     d54:	88 23       	and	r24, r24
     d56:	69 f4       	brne	.+26     	; 0xd72 <xQueueCRReceive+0x2a>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
     d58:	41 15       	cp	r20, r1
     d5a:	51 05       	cpc	r21, r1
     d5c:	39 f0       	breq	.+14     	; 0xd6c <xQueueCRReceive+0x24>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
     d5e:	61 96       	adiw	r28, 0x11	; 17
     d60:	ca 01       	movw	r24, r20
     d62:	be 01       	movw	r22, r28
     d64:	4f de       	rcall	.-866    	; 0xa04 <vCoRoutineAddToDelayedList>
     d66:	78 94       	sei
					portENABLE_INTERRUPTS();
     d68:	8c ef       	ldi	r24, 0xFC	; 252
     d6a:	2e c0       	rjmp	.+92     	; 0xdc8 <xQueueCRReceive+0x80>
     d6c:	78 94       	sei
					return errQUEUE_BLOCKED;
				}
				else
				{
					portENABLE_INTERRUPTS();
     d6e:	80 e0       	ldi	r24, 0x00	; 0
     d70:	2b c0       	rjmp	.+86     	; 0xdc8 <xQueueCRReceive+0x80>
     d72:	78 94       	sei
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
     d74:	f8 94       	cli

		portDISABLE_INTERRUPTS();
     d76:	8a 8d       	ldd	r24, Y+26	; 0x1a
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     d78:	88 23       	and	r24, r24
     d7a:	29 f1       	breq	.+74     	; 0xdc6 <xQueueCRReceive+0x7e>
     d7c:	8c 8d       	ldd	r24, Y+28	; 0x1c
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     d7e:	2e 81       	ldd	r18, Y+6	; 0x06
     d80:	3f 81       	ldd	r19, Y+7	; 0x07
     d82:	28 0f       	add	r18, r24
     d84:	31 1d       	adc	r19, r1
     d86:	3f 83       	std	Y+7, r19	; 0x07
     d88:	2e 83       	std	Y+6, r18	; 0x06
     d8a:	8a 81       	ldd	r24, Y+2	; 0x02
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
     d8c:	9b 81       	ldd	r25, Y+3	; 0x03
     d8e:	28 17       	cp	r18, r24
     d90:	39 07       	cpc	r19, r25
     d92:	20 f0       	brcs	.+8      	; 0xd9c <xQueueCRReceive+0x54>
     d94:	88 81       	ld	r24, Y
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
     d96:	99 81       	ldd	r25, Y+1	; 0x01
     d98:	9f 83       	std	Y+7, r25	; 0x07
     d9a:	8e 83       	std	Y+6, r24	; 0x06
     d9c:	8a 8d       	ldd	r24, Y+26	; 0x1a
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
     d9e:	81 50       	subi	r24, 0x01	; 1
     da0:	8a 8f       	std	Y+26, r24	; 0x1a
     da2:	4c 8d       	ldd	r20, Y+28	; 0x1c
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     da4:	6e 81       	ldd	r22, Y+6	; 0x06
     da6:	7f 81       	ldd	r23, Y+7	; 0x07
     da8:	cf 01       	movw	r24, r30
     daa:	50 e0       	ldi	r21, 0x00	; 0
     dac:	0e 94 5b 12 	call	0x24b6	; 0x24b6 <memcpy>
     db0:	88 85       	ldd	r24, Y+8	; 0x08

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     db2:	88 23       	and	r24, r24
     db4:	39 f0       	breq	.+14     	; 0xdc4 <xQueueCRReceive+0x7c>
     db6:	ce 01       	movw	r24, r28
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     db8:	08 96       	adiw	r24, 0x08	; 8
     dba:	fe dd       	rcall	.-1028   	; 0x9b8 <xCoRoutineRemoveFromEventList>
     dbc:	88 23       	and	r24, r24
     dbe:	11 f0       	breq	.+4      	; 0xdc4 <xQueueCRReceive+0x7c>
     dc0:	8b ef       	ldi	r24, 0xFB	; 251
     dc2:	01 c0       	rjmp	.+2      	; 0xdc6 <xQueueCRReceive+0x7e>
     dc4:	81 e0       	ldi	r24, 0x01	; 1
     dc6:	78 94       	sei
     dc8:	df 91       	pop	r29
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
     dca:	cf 91       	pop	r28

		return xReturn;
	}
     dcc:	08 95       	ret

00000dce <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
     dce:	cf 93       	push	r28
     dd0:	df 93       	push	r29
	BaseType_t xReturn;
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
     dd2:	ec 01       	movw	r28, r24

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
     dd4:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     dd6:	0f b6       	in	r0, 0x3f	; 63
     dd8:	f8 94       	cli
     dda:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     ddc:	8a 8d       	ldd	r24, Y+26	; 0x1a
     dde:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     de0:	0f 90       	pop	r0
     de2:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     de4:	89 17       	cp	r24, r25
     de6:	69 f4       	brne	.+26     	; 0xe02 <xQueueCRSend+0x34>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
     de8:	41 15       	cp	r20, r1
     dea:	51 05       	cpc	r21, r1
     dec:	39 f0       	breq	.+14     	; 0xdfc <xQueueCRSend+0x2e>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
     dee:	28 96       	adiw	r28, 0x08	; 8
     df0:	ca 01       	movw	r24, r20
     df2:	be 01       	movw	r22, r28
     df4:	07 de       	rcall	.-1010   	; 0xa04 <vCoRoutineAddToDelayedList>
     df6:	78 94       	sei
					portENABLE_INTERRUPTS();
     df8:	8c ef       	ldi	r24, 0xFC	; 252
     dfa:	19 c0       	rjmp	.+50     	; 0xe2e <xQueueCRSend+0x60>
     dfc:	78 94       	sei
					return errQUEUE_BLOCKED;
				}
				else
				{
					portENABLE_INTERRUPTS();
     dfe:	80 e0       	ldi	r24, 0x00	; 0
     e00:	16 c0       	rjmp	.+44     	; 0xe2e <xQueueCRSend+0x60>
     e02:	78 94       	sei
					return errQUEUE_FULL;
				}
			}
		}
		portENABLE_INTERRUPTS();
     e04:	f8 94       	cli

		portDISABLE_INTERRUPTS();
     e06:	8a 8d       	ldd	r24, Y+26	; 0x1a
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     e08:	89 17       	cp	r24, r25
     e0a:	10 f0       	brcs	.+4      	; 0xe10 <xQueueCRSend+0x42>
     e0c:	80 e0       	ldi	r24, 0x00	; 0
     e0e:	0e c0       	rjmp	.+28     	; 0xe2c <xQueueCRSend+0x5e>
     e10:	ce 01       	movw	r24, r28
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
     e12:	40 e0       	ldi	r20, 0x00	; 0
     e14:	31 df       	rcall	.-414    	; 0xc78 <prvCopyDataToQueue>
     e16:	89 89       	ldd	r24, Y+17	; 0x11
     e18:	88 23       	and	r24, r24
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     e1a:	39 f0       	breq	.+14     	; 0xe2a <xQueueCRSend+0x5c>
     e1c:	ce 01       	movw	r24, r28
     e1e:	41 96       	adiw	r24, 0x11	; 17
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     e20:	cb dd       	rcall	.-1130   	; 0x9b8 <xCoRoutineRemoveFromEventList>
     e22:	88 23       	and	r24, r24
     e24:	11 f0       	breq	.+4      	; 0xe2a <xQueueCRSend+0x5c>
     e26:	8b ef       	ldi	r24, 0xFB	; 251
     e28:	01 c0       	rjmp	.+2      	; 0xe2c <xQueueCRSend+0x5e>
     e2a:	81 e0       	ldi	r24, 0x01	; 1
     e2c:	78 94       	sei
     e2e:	df 91       	pop	r29
     e30:	cf 91       	pop	r28
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
     e32:	08 95       	ret

00000e34 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
     e34:	cf 93       	push	r28
     e36:	df 93       	push	r29
     e38:	ec 01       	movw	r28, r24
UBaseType_t uxReturn;

	configASSERT( xQueue );
     e3a:	00 97       	sbiw	r24, 0x00	; 0
     e3c:	41 f4       	brne	.+16     	; 0xe4e <uxQueueMessagesWaiting+0x1a>
     e3e:	6f e2       	ldi	r22, 0x2F	; 47
     e40:	76 e0       	ldi	r23, 0x06	; 6
     e42:	80 e0       	ldi	r24, 0x00	; 0
     e44:	90 e0       	ldi	r25, 0x00	; 0
     e46:	47 e3       	ldi	r20, 0x37	; 55
     e48:	52 e0       	ldi	r21, 0x02	; 2
     e4a:	0e 94 12 11 	call	0x2224	; 0x2224 <vAssertCalled>

	taskENTER_CRITICAL();
     e4e:	0f b6       	in	r0, 0x3f	; 63
     e50:	f8 94       	cli
     e52:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
     e54:	8a 8d       	ldd	r24, Y+26	; 0x1a
	}
	taskEXIT_CRITICAL();
     e56:	0f 90       	pop	r0
     e58:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
     e5a:	df 91       	pop	r29
     e5c:	cf 91       	pop	r28
     e5e:	08 95       	ret

00000e60 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
     e60:	cf 92       	push	r12
     e62:	df 92       	push	r13
     e64:	ef 92       	push	r14
     e66:	ff 92       	push	r15
     e68:	0f 93       	push	r16
     e6a:	1f 93       	push	r17
     e6c:	cf 93       	push	r28
     e6e:	df 93       	push	r29
     e70:	7b 01       	movw	r14, r22
     e72:	6a 01       	movw	r12, r20
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
     e74:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );
     e76:	00 97       	sbiw	r24, 0x00	; 0
     e78:	41 f4       	brne	.+16     	; 0xe8a <xQueueReceiveFromISR+0x2a>
     e7a:	60 ea       	ldi	r22, 0xA0	; 160
     e7c:	75 e0       	ldi	r23, 0x05	; 5
     e7e:	80 e0       	ldi	r24, 0x00	; 0
     e80:	90 e0       	ldi	r25, 0x00	; 0
     e82:	47 e3       	ldi	r20, 0x37	; 55
     e84:	52 e0       	ldi	r21, 0x02	; 2
     e86:	0e 94 12 11 	call	0x2224	; 0x2224 <vAssertCalled>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     e8a:	e1 14       	cp	r14, r1
     e8c:	f1 04       	cpc	r15, r1
     e8e:	19 f4       	brne	.+6      	; 0xe96 <xQueueReceiveFromISR+0x36>
     e90:	8c 8d       	ldd	r24, Y+28	; 0x1c
     e92:	88 23       	and	r24, r24
     e94:	41 f5       	brne	.+80     	; 0xee6 <xQueueReceiveFromISR+0x86>
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     e96:	1a 8d       	ldd	r17, Y+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     e98:	11 23       	and	r17, r17
     e9a:	11 f4       	brne	.+4      	; 0xea0 <xQueueReceiveFromISR+0x40>
     e9c:	80 e0       	ldi	r24, 0x00	; 0
     e9e:	1a c0       	rjmp	.+52     	; 0xed4 <xQueueReceiveFromISR+0x74>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
     ea0:	0d 8d       	ldd	r16, Y+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
     ea2:	ce 01       	movw	r24, r28
     ea4:	b7 01       	movw	r22, r14
     ea6:	32 df       	rcall	.-412    	; 0xd0c <prvCopyDataFromQueue>
     ea8:	11 50       	subi	r17, 0x01	; 1
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     eaa:	1a 8f       	std	Y+26, r17	; 0x1a
     eac:	0f 3f       	cpi	r16, 0xFF	; 255

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
     eae:	79 f4       	brne	.+30     	; 0xece <xQueueReceiveFromISR+0x6e>
     eb0:	88 85       	ldd	r24, Y+8	; 0x08
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     eb2:	88 23       	and	r24, r24
     eb4:	71 f0       	breq	.+28     	; 0xed2 <xQueueReceiveFromISR+0x72>
     eb6:	ce 01       	movw	r24, r28
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     eb8:	08 96       	adiw	r24, 0x08	; 8
     eba:	7b d3       	rcall	.+1782   	; 0x15b2 <xTaskRemoveFromEventList>
     ebc:	88 23       	and	r24, r24
     ebe:	49 f0       	breq	.+18     	; 0xed2 <xQueueReceiveFromISR+0x72>
     ec0:	c1 14       	cp	r12, r1
     ec2:	d1 04       	cpc	r13, r1
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
     ec4:	31 f0       	breq	.+12     	; 0xed2 <xQueueReceiveFromISR+0x72>
     ec6:	81 e0       	ldi	r24, 0x01	; 1
     ec8:	f6 01       	movw	r30, r12
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
     eca:	80 83       	st	Z, r24
     ecc:	03 c0       	rjmp	.+6      	; 0xed4 <xQueueReceiveFromISR+0x74>
     ece:	0f 5f       	subi	r16, 0xFF	; 255
     ed0:	0d 8f       	std	Y+29, r16	; 0x1d
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
     ed2:	81 e0       	ldi	r24, 0x01	; 1
     ed4:	df 91       	pop	r29
     ed6:	cf 91       	pop	r28
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     ed8:	1f 91       	pop	r17
     eda:	0f 91       	pop	r16
     edc:	ff 90       	pop	r15
     ede:	ef 90       	pop	r14
     ee0:	df 90       	pop	r13
     ee2:	cf 90       	pop	r12
     ee4:	08 95       	ret
     ee6:	61 ea       	ldi	r22, 0xA1	; 161
     ee8:	75 e0       	ldi	r23, 0x05	; 5
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     eea:	80 e0       	ldi	r24, 0x00	; 0
     eec:	90 e0       	ldi	r25, 0x00	; 0
     eee:	47 e3       	ldi	r20, 0x37	; 55
     ef0:	52 e0       	ldi	r21, 0x02	; 2
     ef2:	0e 94 12 11 	call	0x2224	; 0x2224 <vAssertCalled>
     ef6:	cf cf       	rjmp	.-98     	; 0xe96 <xQueueReceiveFromISR+0x36>

00000ef8 <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
     ef8:	cf 92       	push	r12
     efa:	df 92       	push	r13
     efc:	ef 92       	push	r14
     efe:	ff 92       	push	r15
     f00:	0f 93       	push	r16
     f02:	1f 93       	push	r17
     f04:	cf 93       	push	r28
     f06:	df 93       	push	r29
     f08:	7b 01       	movw	r14, r22
     f0a:	6a 01       	movw	r12, r20
     f0c:	02 2f       	mov	r16, r18
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
     f0e:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );
     f10:	00 97       	sbiw	r24, 0x00	; 0
     f12:	41 f4       	brne	.+16     	; 0xf24 <xQueueGenericSendFromISR+0x2c>
     f14:	6f e9       	ldi	r22, 0x9F	; 159
     f16:	73 e0       	ldi	r23, 0x03	; 3
     f18:	80 e0       	ldi	r24, 0x00	; 0
     f1a:	90 e0       	ldi	r25, 0x00	; 0
     f1c:	47 e3       	ldi	r20, 0x37	; 55
     f1e:	52 e0       	ldi	r21, 0x02	; 2
     f20:	0e 94 12 11 	call	0x2224	; 0x2224 <vAssertCalled>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     f24:	e1 14       	cp	r14, r1
     f26:	f1 04       	cpc	r15, r1
     f28:	19 f4       	brne	.+6      	; 0xf30 <xQueueGenericSendFromISR+0x38>
     f2a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     f2c:	88 23       	and	r24, r24
     f2e:	79 f5       	brne	.+94     	; 0xf8e <xQueueGenericSendFromISR+0x96>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     f30:	02 30       	cpi	r16, 0x02	; 2
     f32:	19 f4       	brne	.+6      	; 0xf3a <xQueueGenericSendFromISR+0x42>
     f34:	8b 8d       	ldd	r24, Y+27	; 0x1b
     f36:	81 30       	cpi	r24, 0x01	; 1
     f38:	99 f5       	brne	.+102    	; 0xfa0 <xQueueGenericSendFromISR+0xa8>
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     f3a:	9a 8d       	ldd	r25, Y+26	; 0x1a
     f3c:	8b 8d       	ldd	r24, Y+27	; 0x1b
     f3e:	98 17       	cp	r25, r24
     f40:	20 f0       	brcs	.+8      	; 0xf4a <xQueueGenericSendFromISR+0x52>
     f42:	02 30       	cpi	r16, 0x02	; 2
     f44:	11 f0       	breq	.+4      	; 0xf4a <xQueueGenericSendFromISR+0x52>
     f46:	80 e0       	ldi	r24, 0x00	; 0
     f48:	19 c0       	rjmp	.+50     	; 0xf7c <xQueueGenericSendFromISR+0x84>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
     f4a:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     f4c:	ce 01       	movw	r24, r28
     f4e:	b7 01       	movw	r22, r14
     f50:	40 2f       	mov	r20, r16
     f52:	92 de       	rcall	.-732    	; 0xc78 <prvCopyDataToQueue>
     f54:	1f 3f       	cpi	r17, 0xFF	; 255

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
     f56:	79 f4       	brne	.+30     	; 0xf76 <xQueueGenericSendFromISR+0x7e>
     f58:	89 89       	ldd	r24, Y+17	; 0x11
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f5a:	88 23       	and	r24, r24
     f5c:	71 f0       	breq	.+28     	; 0xf7a <xQueueGenericSendFromISR+0x82>
     f5e:	ce 01       	movw	r24, r28
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f60:	41 96       	adiw	r24, 0x11	; 17
     f62:	27 d3       	rcall	.+1614   	; 0x15b2 <xTaskRemoveFromEventList>
     f64:	88 23       	and	r24, r24
     f66:	49 f0       	breq	.+18     	; 0xf7a <xQueueGenericSendFromISR+0x82>
     f68:	c1 14       	cp	r12, r1
     f6a:	d1 04       	cpc	r13, r1
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     f6c:	31 f0       	breq	.+12     	; 0xf7a <xQueueGenericSendFromISR+0x82>
     f6e:	81 e0       	ldi	r24, 0x01	; 1
     f70:	f6 01       	movw	r30, r12
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     f72:	80 83       	st	Z, r24
     f74:	03 c0       	rjmp	.+6      	; 0xf7c <xQueueGenericSendFromISR+0x84>
     f76:	1f 5f       	subi	r17, 0xFF	; 255
     f78:	1e 8f       	std	Y+30, r17	; 0x1e
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     f7a:	81 e0       	ldi	r24, 0x01	; 1
     f7c:	df 91       	pop	r29
     f7e:	cf 91       	pop	r28
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     f80:	1f 91       	pop	r17
     f82:	0f 91       	pop	r16
     f84:	ff 90       	pop	r15
     f86:	ef 90       	pop	r14
     f88:	df 90       	pop	r13
     f8a:	cf 90       	pop	r12
     f8c:	08 95       	ret
     f8e:	60 ea       	ldi	r22, 0xA0	; 160
     f90:	73 e0       	ldi	r23, 0x03	; 3
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     f92:	80 e0       	ldi	r24, 0x00	; 0
     f94:	90 e0       	ldi	r25, 0x00	; 0
     f96:	47 e3       	ldi	r20, 0x37	; 55
     f98:	52 e0       	ldi	r21, 0x02	; 2
     f9a:	0e 94 12 11 	call	0x2224	; 0x2224 <vAssertCalled>
     f9e:	c8 cf       	rjmp	.-112    	; 0xf30 <xQueueGenericSendFromISR+0x38>
     fa0:	61 ea       	ldi	r22, 0xA1	; 161
     fa2:	73 e0       	ldi	r23, 0x03	; 3
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     fa4:	80 e0       	ldi	r24, 0x00	; 0
     fa6:	90 e0       	ldi	r25, 0x00	; 0
     fa8:	47 e3       	ldi	r20, 0x37	; 55
     faa:	52 e0       	ldi	r21, 0x02	; 2
     fac:	0e 94 12 11 	call	0x2224	; 0x2224 <vAssertCalled>
     fb0:	c4 cf       	rjmp	.-120    	; 0xf3a <xQueueGenericSendFromISR+0x42>

00000fb2 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     fb2:	ef 92       	push	r14
     fb4:	ff 92       	push	r15
     fb6:	1f 93       	push	r17
     fb8:	cf 93       	push	r28
     fba:	df 93       	push	r29
     fbc:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     fbe:	0f b6       	in	r0, 0x3f	; 63
     fc0:	f8 94       	cli
     fc2:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
     fc4:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     fc6:	91 e1       	ldi	r25, 0x11	; 17
     fc8:	e9 2e       	mov	r14, r25
     fca:	f1 2c       	mov	r15, r1
     fcc:	ec 0e       	add	r14, r28
     fce:	fd 1e       	adc	r15, r29
     fd0:	09 c0       	rjmp	.+18     	; 0xfe4 <prvUnlockQueue+0x32>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     fd2:	89 89       	ldd	r24, Y+17	; 0x11
     fd4:	88 23       	and	r24, r24
     fd6:	41 f0       	breq	.+16     	; 0xfe8 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     fd8:	c7 01       	movw	r24, r14
     fda:	eb d2       	rcall	.+1494   	; 0x15b2 <xTaskRemoveFromEventList>
     fdc:	88 23       	and	r24, r24
     fde:	09 f0       	breq	.+2      	; 0xfe2 <prvUnlockQueue+0x30>
     fe0:	3e d2       	rcall	.+1148   	; 0x145e <vTaskMissedYield>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
     fe2:	11 50       	subi	r17, 0x01	; 1
     fe4:	11 16       	cp	r1, r17
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
     fe6:	ac f3       	brlt	.-22     	; 0xfd2 <prvUnlockQueue+0x20>
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     fe8:	8f ef       	ldi	r24, 0xFF	; 255
     fea:	8e 8f       	std	Y+30, r24	; 0x1e
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
     fec:	0f 90       	pop	r0
     fee:	0f be       	out	0x3f, r0	; 63
	}
	taskEXIT_CRITICAL();
     ff0:	0f b6       	in	r0, 0x3f	; 63
     ff2:	f8 94       	cli

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     ff4:	0f 92       	push	r0
     ff6:	1d 8d       	ldd	r17, Y+29	; 0x1d
     ff8:	88 e0       	ldi	r24, 0x08	; 8
	{
		int8_t cRxLock = pxQueue->cRxLock;
     ffa:	e8 2e       	mov	r14, r24

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     ffc:	f1 2c       	mov	r15, r1
     ffe:	ec 0e       	add	r14, r28
    1000:	fd 1e       	adc	r15, r29
    1002:	09 c0       	rjmp	.+18     	; 0x1016 <prvUnlockQueue+0x64>
    1004:	88 85       	ldd	r24, Y+8	; 0x08
    1006:	88 23       	and	r24, r24
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1008:	41 f0       	breq	.+16     	; 0x101a <prvUnlockQueue+0x68>
    100a:	c7 01       	movw	r24, r14
    100c:	d2 d2       	rcall	.+1444   	; 0x15b2 <xTaskRemoveFromEventList>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    100e:	88 23       	and	r24, r24
    1010:	09 f0       	breq	.+2      	; 0x1014 <prvUnlockQueue+0x62>
    1012:	25 d2       	rcall	.+1098   	; 0x145e <vTaskMissedYield>
    1014:	11 50       	subi	r17, 0x01	; 1
    1016:	11 16       	cp	r1, r17
				{
					vTaskMissedYield();
    1018:	ac f3       	brlt	.-22     	; 0x1004 <prvUnlockQueue+0x52>
    101a:	8f ef       	ldi	r24, 0xFF	; 255
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    101c:	8d 8f       	std	Y+29, r24	; 0x1d
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    101e:	0f 90       	pop	r0
    1020:	0f be       	out	0x3f, r0	; 63
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1022:	df 91       	pop	r29
    1024:	cf 91       	pop	r28
	}
	taskEXIT_CRITICAL();
    1026:	1f 91       	pop	r17
    1028:	ff 90       	pop	r15
}
    102a:	ef 90       	pop	r14
    102c:	08 95       	ret

0000102e <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    102e:	6f 92       	push	r6
    1030:	7f 92       	push	r7
    1032:	8f 92       	push	r8
    1034:	9f 92       	push	r9
    1036:	af 92       	push	r10
    1038:	bf 92       	push	r11
    103a:	cf 92       	push	r12
    103c:	df 92       	push	r13
    103e:	ef 92       	push	r14
    1040:	ff 92       	push	r15
    1042:	0f 93       	push	r16
    1044:	1f 93       	push	r17
    1046:	df 93       	push	r29
    1048:	cf 93       	push	r28
    104a:	00 d0       	rcall	.+0      	; 0x104c <xQueueGenericReceive+0x1e>
    104c:	0f 92       	push	r0
    104e:	0f 92       	push	r0
    1050:	cd b7       	in	r28, 0x3d	; 61
    1052:	de b7       	in	r29, 0x3e	; 62
    1054:	4b 01       	movw	r8, r22
    1056:	5d 83       	std	Y+5, r21	; 0x05
    1058:	4c 83       	std	Y+4, r20	; 0x04
    105a:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    105c:	8c 01       	movw	r16, r24

	configASSERT( pxQueue );
    105e:	00 97       	sbiw	r24, 0x00	; 0
    1060:	41 f4       	brne	.+16     	; 0x1072 <xQueueGenericReceive+0x44>
    1062:	6c ed       	ldi	r22, 0xDC	; 220
    1064:	74 e0       	ldi	r23, 0x04	; 4
    1066:	80 e0       	ldi	r24, 0x00	; 0
    1068:	90 e0       	ldi	r25, 0x00	; 0
    106a:	47 e3       	ldi	r20, 0x37	; 55
    106c:	52 e0       	ldi	r21, 0x02	; 2
    106e:	0e 94 12 11 	call	0x2224	; 0x2224 <vAssertCalled>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    1072:	81 14       	cp	r8, r1
    1074:	91 04       	cpc	r9, r1
    1076:	29 f4       	brne	.+10     	; 0x1082 <xQueueGenericReceive+0x54>
    1078:	f8 01       	movw	r30, r16
    107a:	84 8d       	ldd	r24, Z+28	; 0x1c
    107c:	88 23       	and	r24, r24
    107e:	09 f0       	breq	.+2      	; 0x1082 <xQueueGenericReceive+0x54>
    1080:	94 c0       	rjmp	.+296    	; 0x11aa <xQueueGenericReceive+0x17c>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1082:	41 e1       	ldi	r20, 0x11	; 17
    1084:	a4 2e       	mov	r10, r20
    1086:	b1 2c       	mov	r11, r1
    1088:	a0 0e       	add	r10, r16
    108a:	b1 1e       	adc	r11, r17
    108c:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    108e:	6e 01       	movw	r12, r28
    1090:	08 94       	sec
    1092:	c1 1c       	adc	r12, r1
    1094:	d1 1c       	adc	r13, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1096:	34 e0       	ldi	r19, 0x04	; 4
    1098:	63 2e       	mov	r6, r19
    109a:	71 2c       	mov	r7, r1
    109c:	6c 0e       	add	r6, r28
    109e:	7d 1e       	adc	r7, r29
    10a0:	01 c0       	rjmp	.+2      	; 0x10a4 <xQueueGenericReceive+0x76>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    10a2:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    10a4:	0f b6       	in	r0, 0x3f	; 63
    10a6:	f8 94       	cli
    10a8:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    10aa:	f8 01       	movw	r30, r16
    10ac:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    10ae:	ff 20       	and	r15, r15
    10b0:	f9 f0       	breq	.+62     	; 0x10f0 <xQueueGenericReceive+0xc2>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    10b2:	c6 80       	ldd	r12, Z+6	; 0x06
    10b4:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    10b6:	c8 01       	movw	r24, r16
    10b8:	b4 01       	movw	r22, r8
    10ba:	28 de       	rcall	.-944    	; 0xd0c <prvCopyDataFromQueue>
    10bc:	ee 20       	and	r14, r14

				if( xJustPeeking == pdFALSE )
    10be:	49 f4       	brne	.+18     	; 0x10d2 <xQueueGenericReceive+0xa4>
    10c0:	fa 94       	dec	r15
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    10c2:	f8 01       	movw	r30, r16
    10c4:	f2 8e       	std	Z+26, r15	; 0x1a
    10c6:	80 85       	ldd	r24, Z+8	; 0x08
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10c8:	88 23       	and	r24, r24
    10ca:	71 f0       	breq	.+28     	; 0x10e8 <xQueueGenericReceive+0xba>
    10cc:	c8 01       	movw	r24, r16
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10ce:	08 96       	adiw	r24, 0x08	; 8
    10d0:	07 c0       	rjmp	.+14     	; 0x10e0 <xQueueGenericReceive+0xb2>
    10d2:	f8 01       	movw	r30, r16
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    10d4:	d7 82       	std	Z+7, r13	; 0x07
    10d6:	c6 82       	std	Z+6, r12	; 0x06
    10d8:	81 89       	ldd	r24, Z+17	; 0x11

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    10da:	88 23       	and	r24, r24
    10dc:	29 f0       	breq	.+10     	; 0x10e8 <xQueueGenericReceive+0xba>
    10de:	c5 01       	movw	r24, r10
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    10e0:	68 d2       	rcall	.+1232   	; 0x15b2 <xTaskRemoveFromEventList>
    10e2:	88 23       	and	r24, r24
    10e4:	09 f0       	breq	.+2      	; 0x10e8 <xQueueGenericReceive+0xba>
    10e6:	cd db       	rcall	.-2150   	; 0x882 <vPortYield>
    10e8:	0f 90       	pop	r0
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    10ea:	0f be       	out	0x3f, r0	; 63
    10ec:	81 e0       	ldi	r24, 0x01	; 1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    10ee:	49 c0       	rjmp	.+146    	; 0x1182 <xQueueGenericReceive+0x154>
    10f0:	8c 81       	ldd	r24, Y+4	; 0x04
    10f2:	9d 81       	ldd	r25, Y+5	; 0x05
    10f4:	89 2b       	or	r24, r25
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    10f6:	21 f4       	brne	.+8      	; 0x1100 <xQueueGenericReceive+0xd2>
    10f8:	0f 90       	pop	r0
    10fa:	0f be       	out	0x3f, r0	; 63
    10fc:	80 e0       	ldi	r24, 0x00	; 0
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    10fe:	41 c0       	rjmp	.+130    	; 0x1182 <xQueueGenericReceive+0x154>
    1100:	22 23       	and	r18, r18
    1102:	11 f4       	brne	.+4      	; 0x1108 <xQueueGenericReceive+0xda>
    1104:	c6 01       	movw	r24, r12
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1106:	af d1       	rcall	.+862    	; 0x1466 <vTaskSetTimeOutState>
    1108:	0f 90       	pop	r0
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    110a:	0f be       	out	0x3f, r0	; 63
    110c:	97 d1       	rcall	.+814    	; 0x143c <vTaskSuspendAll>
    110e:	0f b6       	in	r0, 0x3f	; 63
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1110:	f8 94       	cli
    1112:	0f 92       	push	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1114:	f8 01       	movw	r30, r16
    1116:	85 8d       	ldd	r24, Z+29	; 0x1d
		prvLockQueue( pxQueue );
    1118:	8f 3f       	cpi	r24, 0xFF	; 255
    111a:	09 f4       	brne	.+2      	; 0x111e <xQueueGenericReceive+0xf0>
    111c:	15 8e       	std	Z+29, r1	; 0x1d
    111e:	f8 01       	movw	r30, r16
    1120:	86 8d       	ldd	r24, Z+30	; 0x1e
    1122:	8f 3f       	cpi	r24, 0xFF	; 255
    1124:	09 f4       	brne	.+2      	; 0x1128 <xQueueGenericReceive+0xfa>
    1126:	16 8e       	std	Z+30, r1	; 0x1e
    1128:	0f 90       	pop	r0
    112a:	0f be       	out	0x3f, r0	; 63
    112c:	c6 01       	movw	r24, r12
    112e:	b3 01       	movw	r22, r6
    1130:	b2 d1       	rcall	.+868    	; 0x1496 <xTaskCheckForTimeOut>
    1132:	88 23       	and	r24, r24
    1134:	c9 f4       	brne	.+50     	; 0x1168 <xQueueGenericReceive+0x13a>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1136:	0f b6       	in	r0, 0x3f	; 63
    1138:	f8 94       	cli
    113a:	0f 92       	push	r0
    113c:	f8 01       	movw	r30, r16
    113e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1140:	0f 90       	pop	r0

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1142:	0f be       	out	0x3f, r0	; 63
    1144:	88 23       	and	r24, r24
    1146:	61 f4       	brne	.+24     	; 0x1160 <xQueueGenericReceive+0x132>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1148:	6c 81       	ldd	r22, Y+4	; 0x04
    114a:	7d 81       	ldd	r23, Y+5	; 0x05
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    114c:	c5 01       	movw	r24, r10
    114e:	99 d4       	rcall	.+2354   	; 0x1a82 <vTaskPlaceOnEventList>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1150:	c8 01       	movw	r24, r16
    1152:	2f df       	rcall	.-418    	; 0xfb2 <prvUnlockQueue>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1154:	48 d3       	rcall	.+1680   	; 0x17e6 <xTaskResumeAll>
    1156:	88 23       	and	r24, r24
    1158:	09 f0       	breq	.+2      	; 0x115c <xQueueGenericReceive+0x12e>
    115a:	a3 cf       	rjmp	.-186    	; 0x10a2 <xQueueGenericReceive+0x74>
    115c:	92 db       	rcall	.-2268   	; 0x882 <vPortYield>
				prvUnlockQueue( pxQueue );
    115e:	a1 cf       	rjmp	.-190    	; 0x10a2 <xQueueGenericReceive+0x74>
    1160:	c8 01       	movw	r24, r16
    1162:	27 df       	rcall	.-434    	; 0xfb2 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1164:	40 d3       	rcall	.+1664   	; 0x17e6 <xTaskResumeAll>
    1166:	9d cf       	rjmp	.-198    	; 0x10a2 <xQueueGenericReceive+0x74>
    1168:	c8 01       	movw	r24, r16
    116a:	23 df       	rcall	.-442    	; 0xfb2 <prvUnlockQueue>
    116c:	3c d3       	rcall	.+1656   	; 0x17e6 <xTaskResumeAll>
				{
					portYIELD_WITHIN_API();
    116e:	0f b6       	in	r0, 0x3f	; 63
    1170:	f8 94       	cli
    1172:	0f 92       	push	r0
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1174:	f8 01       	movw	r30, r16
    1176:	82 8d       	ldd	r24, Z+26	; 0x1a
    1178:	0f 90       	pop	r0
				( void ) xTaskResumeAll();
    117a:	0f be       	out	0x3f, r0	; 63
    117c:	88 23       	and	r24, r24
    117e:	09 f0       	breq	.+2      	; 0x1182 <xQueueGenericReceive+0x154>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1180:	90 cf       	rjmp	.-224    	; 0x10a2 <xQueueGenericReceive+0x74>
    1182:	0f 90       	pop	r0
    1184:	0f 90       	pop	r0
			( void ) xTaskResumeAll();
    1186:	0f 90       	pop	r0
    1188:	0f 90       	pop	r0

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    118a:	0f 90       	pop	r0
    118c:	cf 91       	pop	r28
    118e:	df 91       	pop	r29
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1190:	1f 91       	pop	r17
    1192:	0f 91       	pop	r16
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1194:	ff 90       	pop	r15
    1196:	ef 90       	pop	r14
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1198:	df 90       	pop	r13
    119a:	cf 90       	pop	r12
    119c:	bf 90       	pop	r11
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    119e:	af 90       	pop	r10
    11a0:	9f 90       	pop	r9
    11a2:	8f 90       	pop	r8
    11a4:	7f 90       	pop	r7
    11a6:	6f 90       	pop	r6
    11a8:	08 95       	ret
    11aa:	6d ed       	ldi	r22, 0xDD	; 221
    11ac:	74 e0       	ldi	r23, 0x04	; 4
    11ae:	80 e0       	ldi	r24, 0x00	; 0
    11b0:	90 e0       	ldi	r25, 0x00	; 0
    11b2:	47 e3       	ldi	r20, 0x37	; 55
    11b4:	52 e0       	ldi	r21, 0x02	; 2
    11b6:	0e 94 12 11 	call	0x2224	; 0x2224 <vAssertCalled>
    11ba:	63 cf       	rjmp	.-314    	; 0x1082 <xQueueGenericReceive+0x54>

000011bc <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    11bc:	6f 92       	push	r6
    11be:	7f 92       	push	r7
    11c0:	8f 92       	push	r8
    11c2:	9f 92       	push	r9
    11c4:	af 92       	push	r10
    11c6:	bf 92       	push	r11
    11c8:	cf 92       	push	r12
    11ca:	df 92       	push	r13
    11cc:	ff 92       	push	r15
    11ce:	0f 93       	push	r16
    11d0:	1f 93       	push	r17
    11d2:	df 93       	push	r29
    11d4:	cf 93       	push	r28
    11d6:	00 d0       	rcall	.+0      	; 0x11d8 <xQueueGenericSend+0x1c>
    11d8:	0f 92       	push	r0
    11da:	0f 92       	push	r0
    11dc:	cd b7       	in	r28, 0x3d	; 61
    11de:	de b7       	in	r29, 0x3e	; 62
    11e0:	6b 01       	movw	r12, r22
    11e2:	5d 83       	std	Y+5, r21	; 0x05
    11e4:	4c 83       	std	Y+4, r20	; 0x04
    11e6:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    11e8:	8c 01       	movw	r16, r24

	configASSERT( pxQueue );
    11ea:	00 97       	sbiw	r24, 0x00	; 0
    11ec:	41 f4       	brne	.+16     	; 0x11fe <xQueueGenericSend+0x42>
    11ee:	69 ed       	ldi	r22, 0xD9	; 217
    11f0:	72 e0       	ldi	r23, 0x02	; 2
    11f2:	80 e0       	ldi	r24, 0x00	; 0
    11f4:	90 e0       	ldi	r25, 0x00	; 0
    11f6:	47 e3       	ldi	r20, 0x37	; 55
    11f8:	52 e0       	ldi	r21, 0x02	; 2
    11fa:	0e 94 12 11 	call	0x2224	; 0x2224 <vAssertCalled>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    11fe:	c1 14       	cp	r12, r1
    1200:	d1 04       	cpc	r13, r1
    1202:	29 f4       	brne	.+10     	; 0x120e <xQueueGenericSend+0x52>
    1204:	f8 01       	movw	r30, r16
    1206:	84 8d       	ldd	r24, Z+28	; 0x1c
    1208:	88 23       	and	r24, r24
    120a:	09 f0       	breq	.+2      	; 0x120e <xQueueGenericSend+0x52>
    120c:	8e c0       	rjmp	.+284    	; 0x132a <xQueueGenericSend+0x16e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    120e:	f2 e0       	ldi	r31, 0x02	; 2
    1210:	ff 16       	cp	r15, r31
    1212:	29 f4       	brne	.+10     	; 0x121e <xQueueGenericSend+0x62>
    1214:	f8 01       	movw	r30, r16
    1216:	83 8d       	ldd	r24, Z+27	; 0x1b
    1218:	81 30       	cpi	r24, 0x01	; 1
    121a:	09 f0       	breq	.+2      	; 0x121e <xQueueGenericSend+0x62>
    121c:	8e c0       	rjmp	.+284    	; 0x133a <xQueueGenericSend+0x17e>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    121e:	68 e0       	ldi	r22, 0x08	; 8
    1220:	a6 2e       	mov	r10, r22
    1222:	b1 2c       	mov	r11, r1
    1224:	a0 0e       	add	r10, r16
    1226:	b1 1e       	adc	r11, r17
    1228:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    122a:	4e 01       	movw	r8, r28
    122c:	08 94       	sec
    122e:	81 1c       	adc	r8, r1
    1230:	91 1c       	adc	r9, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1232:	54 e0       	ldi	r21, 0x04	; 4
    1234:	65 2e       	mov	r6, r21
    1236:	71 2c       	mov	r7, r1
    1238:	6c 0e       	add	r6, r28
    123a:	7d 1e       	adc	r7, r29
    123c:	01 c0       	rjmp	.+2      	; 0x1240 <xQueueGenericSend+0x84>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    123e:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1240:	0f b6       	in	r0, 0x3f	; 63
    1242:	f8 94       	cli
    1244:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1246:	f8 01       	movw	r30, r16
    1248:	92 8d       	ldd	r25, Z+26	; 0x1a
    124a:	83 8d       	ldd	r24, Z+27	; 0x1b
    124c:	98 17       	cp	r25, r24
    124e:	18 f0       	brcs	.+6      	; 0x1256 <xQueueGenericSend+0x9a>
    1250:	f2 e0       	ldi	r31, 0x02	; 2
    1252:	ff 16       	cp	r15, r31
    1254:	b1 f4       	brne	.+44     	; 0x1282 <xQueueGenericSend+0xc6>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1256:	c8 01       	movw	r24, r16
    1258:	b6 01       	movw	r22, r12
    125a:	4f 2d       	mov	r20, r15
    125c:	0d dd       	rcall	.-1510   	; 0xc78 <prvCopyDataToQueue>
    125e:	98 2f       	mov	r25, r24
    1260:	f8 01       	movw	r30, r16
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1262:	81 89       	ldd	r24, Z+17	; 0x11
    1264:	88 23       	and	r24, r24
    1266:	31 f0       	breq	.+12     	; 0x1274 <xQueueGenericSend+0xb8>
    1268:	c8 01       	movw	r24, r16
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    126a:	41 96       	adiw	r24, 0x11	; 17
    126c:	a2 d1       	rcall	.+836    	; 0x15b2 <xTaskRemoveFromEventList>
    126e:	88 23       	and	r24, r24
    1270:	21 f0       	breq	.+8      	; 0x127a <xQueueGenericSend+0xbe>
    1272:	02 c0       	rjmp	.+4      	; 0x1278 <xQueueGenericSend+0xbc>
    1274:	99 23       	and	r25, r25
    1276:	09 f0       	breq	.+2      	; 0x127a <xQueueGenericSend+0xbe>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1278:	04 db       	rcall	.-2552   	; 0x882 <vPortYield>
    127a:	0f 90       	pop	r0
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    127c:	0f be       	out	0x3f, r0	; 63
    127e:	81 e0       	ldi	r24, 0x01	; 1
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1280:	41 c0       	rjmp	.+130    	; 0x1304 <xQueueGenericSend+0x148>
    1282:	8c 81       	ldd	r24, Y+4	; 0x04
    1284:	9d 81       	ldd	r25, Y+5	; 0x05
    1286:	89 2b       	or	r24, r25
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1288:	19 f4       	brne	.+6      	; 0x1290 <xQueueGenericSend+0xd4>
    128a:	0f 90       	pop	r0
    128c:	0f be       	out	0x3f, r0	; 63
    128e:	39 c0       	rjmp	.+114    	; 0x1302 <xQueueGenericSend+0x146>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1290:	22 23       	and	r18, r18
    1292:	11 f4       	brne	.+4      	; 0x1298 <xQueueGenericSend+0xdc>
    1294:	c4 01       	movw	r24, r8
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1296:	e7 d0       	rcall	.+462    	; 0x1466 <vTaskSetTimeOutState>
    1298:	0f 90       	pop	r0
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    129a:	0f be       	out	0x3f, r0	; 63
    129c:	cf d0       	rcall	.+414    	; 0x143c <vTaskSuspendAll>
    129e:	0f b6       	in	r0, 0x3f	; 63
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    12a0:	f8 94       	cli
    12a2:	0f 92       	push	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    12a4:	f8 01       	movw	r30, r16
    12a6:	85 8d       	ldd	r24, Z+29	; 0x1d
		prvLockQueue( pxQueue );
    12a8:	8f 3f       	cpi	r24, 0xFF	; 255
    12aa:	09 f4       	brne	.+2      	; 0x12ae <xQueueGenericSend+0xf2>
    12ac:	15 8e       	std	Z+29, r1	; 0x1d
    12ae:	f8 01       	movw	r30, r16
    12b0:	86 8d       	ldd	r24, Z+30	; 0x1e
    12b2:	8f 3f       	cpi	r24, 0xFF	; 255
    12b4:	09 f4       	brne	.+2      	; 0x12b8 <xQueueGenericSend+0xfc>
    12b6:	16 8e       	std	Z+30, r1	; 0x1e
    12b8:	0f 90       	pop	r0
    12ba:	0f be       	out	0x3f, r0	; 63
    12bc:	c4 01       	movw	r24, r8
    12be:	b3 01       	movw	r22, r6
    12c0:	ea d0       	rcall	.+468    	; 0x1496 <xTaskCheckForTimeOut>
    12c2:	88 23       	and	r24, r24
    12c4:	d9 f4       	brne	.+54     	; 0x12fc <xQueueGenericSend+0x140>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    12c6:	0f b6       	in	r0, 0x3f	; 63
    12c8:	f8 94       	cli
    12ca:	0f 92       	push	r0
    12cc:	f8 01       	movw	r30, r16
    12ce:	92 8d       	ldd	r25, Z+26	; 0x1a
    12d0:	0f 90       	pop	r0

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    12d2:	0f be       	out	0x3f, r0	; 63
    12d4:	f8 01       	movw	r30, r16
    12d6:	83 8d       	ldd	r24, Z+27	; 0x1b
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    12d8:	98 17       	cp	r25, r24
    12da:	61 f4       	brne	.+24     	; 0x12f4 <xQueueGenericSend+0x138>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    12dc:	6c 81       	ldd	r22, Y+4	; 0x04
    12de:	7d 81       	ldd	r23, Y+5	; 0x05
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    12e0:	c5 01       	movw	r24, r10
    12e2:	cf d3       	rcall	.+1950   	; 0x1a82 <vTaskPlaceOnEventList>
    12e4:	c8 01       	movw	r24, r16
    12e6:	65 de       	rcall	.-822    	; 0xfb2 <prvUnlockQueue>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    12e8:	7e d2       	rcall	.+1276   	; 0x17e6 <xTaskResumeAll>
    12ea:	88 23       	and	r24, r24
    12ec:	09 f0       	breq	.+2      	; 0x12f0 <xQueueGenericSend+0x134>
    12ee:	a7 cf       	rjmp	.-178    	; 0x123e <xQueueGenericSend+0x82>
    12f0:	c8 da       	rcall	.-2672   	; 0x882 <vPortYield>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    12f2:	a5 cf       	rjmp	.-182    	; 0x123e <xQueueGenericSend+0x82>
    12f4:	c8 01       	movw	r24, r16
    12f6:	5d de       	rcall	.-838    	; 0xfb2 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    12f8:	76 d2       	rcall	.+1260   	; 0x17e6 <xTaskResumeAll>
    12fa:	a1 cf       	rjmp	.-190    	; 0x123e <xQueueGenericSend+0x82>
    12fc:	c8 01       	movw	r24, r16
    12fe:	59 de       	rcall	.-846    	; 0xfb2 <prvUnlockQueue>
    1300:	72 d2       	rcall	.+1252   	; 0x17e6 <xTaskResumeAll>
				{
					portYIELD_WITHIN_API();
    1302:	80 e0       	ldi	r24, 0x00	; 0
    1304:	0f 90       	pop	r0
    1306:	0f 90       	pop	r0
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1308:	0f 90       	pop	r0
    130a:	0f 90       	pop	r0
    130c:	0f 90       	pop	r0
				( void ) xTaskResumeAll();
    130e:	cf 91       	pop	r28
    1310:	df 91       	pop	r29
    1312:	1f 91       	pop	r17
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1314:	0f 91       	pop	r16
    1316:	ff 90       	pop	r15
    1318:	df 90       	pop	r13
			( void ) xTaskResumeAll();
    131a:	cf 90       	pop	r12
    131c:	bf 90       	pop	r11
    131e:	af 90       	pop	r10

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    1320:	9f 90       	pop	r9
    1322:	8f 90       	pop	r8
    1324:	7f 90       	pop	r7
    1326:	6f 90       	pop	r6
    1328:	08 95       	ret
    132a:	6a ed       	ldi	r22, 0xDA	; 218
    132c:	72 e0       	ldi	r23, 0x02	; 2
    132e:	80 e0       	ldi	r24, 0x00	; 0
    1330:	90 e0       	ldi	r25, 0x00	; 0
    1332:	47 e3       	ldi	r20, 0x37	; 55
    1334:	52 e0       	ldi	r21, 0x02	; 2
    1336:	76 d7       	rcall	.+3820   	; 0x2224 <vAssertCalled>
    1338:	6a cf       	rjmp	.-300    	; 0x120e <xQueueGenericSend+0x52>
    133a:	6b ed       	ldi	r22, 0xDB	; 219
    133c:	72 e0       	ldi	r23, 0x02	; 2
    133e:	80 e0       	ldi	r24, 0x00	; 0
    1340:	90 e0       	ldi	r25, 0x00	; 0
    1342:	47 e3       	ldi	r20, 0x37	; 55
    1344:	52 e0       	ldi	r21, 0x02	; 2
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    1346:	6e d7       	rcall	.+3804   	; 0x2224 <vAssertCalled>
    1348:	6a cf       	rjmp	.-300    	; 0x121e <xQueueGenericSend+0x62>

0000134a <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    134a:	1f 93       	push	r17
    134c:	cf 93       	push	r28
    134e:	df 93       	push	r29
    1350:	16 2f       	mov	r17, r22
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1352:	ec 01       	movw	r28, r24

	configASSERT( pxQueue );
    1354:	00 97       	sbiw	r24, 0x00	; 0
    1356:	39 f4       	brne	.+14     	; 0x1366 <xQueueGenericReset+0x1c>
    1358:	6b e1       	ldi	r22, 0x1B	; 27
    135a:	71 e0       	ldi	r23, 0x01	; 1
    135c:	80 e0       	ldi	r24, 0x00	; 0
    135e:	90 e0       	ldi	r25, 0x00	; 0
    1360:	47 e3       	ldi	r20, 0x37	; 55
    1362:	52 e0       	ldi	r21, 0x02	; 2
    1364:	5f d7       	rcall	.+3774   	; 0x2224 <vAssertCalled>
    1366:	0f b6       	in	r0, 0x3f	; 63

	taskENTER_CRITICAL();
    1368:	f8 94       	cli
    136a:	0f 92       	push	r0
    136c:	6c 8d       	ldd	r22, Y+28	; 0x1c
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    136e:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1370:	62 9f       	mul	r22, r18
    1372:	c0 01       	movw	r24, r0
    1374:	11 24       	eor	r1, r1
    1376:	48 81       	ld	r20, Y
    1378:	59 81       	ldd	r21, Y+1	; 0x01
    137a:	84 0f       	add	r24, r20
    137c:	95 1f       	adc	r25, r21
    137e:	9b 83       	std	Y+3, r25	; 0x03
    1380:	8a 83       	std	Y+2, r24	; 0x02
    1382:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1384:	5d 83       	std	Y+5, r21	; 0x05
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1386:	4c 83       	std	Y+4, r20	; 0x04
    1388:	30 e0       	ldi	r19, 0x00	; 0
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    138a:	21 50       	subi	r18, 0x01	; 1
    138c:	30 40       	sbci	r19, 0x00	; 0
    138e:	70 e0       	ldi	r23, 0x00	; 0
    1390:	26 9f       	mul	r18, r22
    1392:	c0 01       	movw	r24, r0
    1394:	27 9f       	mul	r18, r23
    1396:	90 0d       	add	r25, r0
    1398:	36 9f       	mul	r19, r22
    139a:	90 0d       	add	r25, r0
    139c:	11 24       	eor	r1, r1
    139e:	48 0f       	add	r20, r24
    13a0:	59 1f       	adc	r21, r25
    13a2:	5f 83       	std	Y+7, r21	; 0x07
    13a4:	4e 83       	std	Y+6, r20	; 0x06
    13a6:	8f ef       	ldi	r24, 0xFF	; 255
		pxQueue->cRxLock = queueUNLOCKED;
    13a8:	8d 8f       	std	Y+29, r24	; 0x1d
    13aa:	8e 8f       	std	Y+30, r24	; 0x1e
		pxQueue->cTxLock = queueUNLOCKED;
    13ac:	11 23       	and	r17, r17

		if( xNewQueue == pdFALSE )
    13ae:	51 f4       	brne	.+20     	; 0x13c4 <xQueueGenericReset+0x7a>
    13b0:	88 85       	ldd	r24, Y+8	; 0x08
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13b2:	88 23       	and	r24, r24
    13b4:	69 f0       	breq	.+26     	; 0x13d0 <xQueueGenericReset+0x86>
    13b6:	ce 01       	movw	r24, r28
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    13b8:	08 96       	adiw	r24, 0x08	; 8
    13ba:	fb d0       	rcall	.+502    	; 0x15b2 <xTaskRemoveFromEventList>
    13bc:	88 23       	and	r24, r24
    13be:	41 f0       	breq	.+16     	; 0x13d0 <xQueueGenericReset+0x86>
    13c0:	60 da       	rcall	.-2880   	; 0x882 <vPortYield>
    13c2:	06 c0       	rjmp	.+12     	; 0x13d0 <xQueueGenericReset+0x86>
				{
					queueYIELD_IF_USING_PREEMPTION();
    13c4:	ce 01       	movw	r24, r28
    13c6:	08 96       	adiw	r24, 0x08	; 8
    13c8:	c8 db       	rcall	.-2160   	; 0xb5a <vListInitialise>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    13ca:	ce 01       	movw	r24, r28
    13cc:	41 96       	adiw	r24, 0x11	; 17
    13ce:	c5 db       	rcall	.-2166   	; 0xb5a <vListInitialise>
    13d0:	0f 90       	pop	r0
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    13d2:	0f be       	out	0x3f, r0	; 63
    13d4:	81 e0       	ldi	r24, 0x01	; 1
    13d6:	df 91       	pop	r29
    13d8:	cf 91       	pop	r28
		}
	}
	taskEXIT_CRITICAL();
    13da:	1f 91       	pop	r17
    13dc:	08 95       	ret

000013de <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    13de:	0f 93       	push	r16
    13e0:	1f 93       	push	r17
    13e2:	cf 93       	push	r28
    13e4:	df 93       	push	r29
    13e6:	08 2f       	mov	r16, r24
    13e8:	16 2f       	mov	r17, r22
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    13ea:	88 23       	and	r24, r24
    13ec:	39 f4       	brne	.+14     	; 0x13fc <xQueueGenericCreate+0x1e>
    13ee:	68 e8       	ldi	r22, 0x88	; 136
    13f0:	71 e0       	ldi	r23, 0x01	; 1
    13f2:	80 e0       	ldi	r24, 0x00	; 0
    13f4:	90 e0       	ldi	r25, 0x00	; 0
    13f6:	47 e3       	ldi	r20, 0x37	; 55
    13f8:	52 e0       	ldi	r21, 0x02	; 2
    13fa:	14 d7       	rcall	.+3624   	; 0x2224 <vAssertCalled>
    13fc:	11 23       	and	r17, r17

		if( uxItemSize == ( UBaseType_t ) 0 )
    13fe:	19 f4       	brne	.+6      	; 0x1406 <xQueueGenericCreate+0x28>
    1400:	80 e0       	ldi	r24, 0x00	; 0
    1402:	90 e0       	ldi	r25, 0x00	; 0
    1404:	03 c0       	rjmp	.+6      	; 0x140c <xQueueGenericCreate+0x2e>
    1406:	10 9f       	mul	r17, r16
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1408:	c0 01       	movw	r24, r0
    140a:	11 24       	eor	r1, r1
    140c:	4f 96       	adiw	r24, 0x1f	; 31
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    140e:	a4 da       	rcall	.-2744   	; 0x958 <pvPortMalloc>
    1410:	ec 01       	movw	r28, r24
    1412:	00 97       	sbiw	r24, 0x00	; 0
    1414:	69 f0       	breq	.+26     	; 0x1430 <xQueueGenericCreate+0x52>

		if( pxNewQueue != NULL )
    1416:	11 23       	and	r17, r17
    1418:	19 f4       	brne	.+6      	; 0x1420 <xQueueGenericCreate+0x42>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    141a:	99 83       	std	Y+1, r25	; 0x01
    141c:	88 83       	st	Y, r24
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    141e:	03 c0       	rjmp	.+6      	; 0x1426 <xQueueGenericCreate+0x48>
    1420:	4f 96       	adiw	r24, 0x1f	; 31
    1422:	99 83       	std	Y+1, r25	; 0x01
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1424:	88 83       	st	Y, r24
    1426:	0b 8f       	std	Y+27, r16	; 0x1b
    1428:	1c 8f       	std	Y+28, r17	; 0x1c
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    142a:	ce 01       	movw	r24, r28
	pxNewQueue->uxItemSize = uxItemSize;
    142c:	61 e0       	ldi	r22, 0x01	; 1
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    142e:	8d df       	rcall	.-230    	; 0x134a <xQueueGenericReset>
    1430:	ce 01       	movw	r24, r28
    1432:	df 91       	pop	r29
    1434:	cf 91       	pop	r28

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
    1436:	1f 91       	pop	r17
    1438:	0f 91       	pop	r16
    143a:	08 95       	ret

0000143c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    143c:	80 91 45 20 	lds	r24, 0x2045
    1440:	8f 5f       	subi	r24, 0xFF	; 255
    1442:	80 93 45 20 	sts	0x2045, r24
}
    1446:	08 95       	ret

00001448 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    1448:	0f b6       	in	r0, 0x3f	; 63
    144a:	f8 94       	cli
    144c:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    144e:	20 91 48 20 	lds	r18, 0x2048
    1452:	30 91 49 20 	lds	r19, 0x2049
	}
	portTICK_TYPE_EXIT_CRITICAL();
    1456:	0f 90       	pop	r0
    1458:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    145a:	c9 01       	movw	r24, r18
    145c:	08 95       	ret

0000145e <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    145e:	81 e0       	ldi	r24, 0x01	; 1
    1460:	80 93 47 20 	sts	0x2047, r24
}
    1464:	08 95       	ret

00001466 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    1466:	cf 93       	push	r28
    1468:	df 93       	push	r29
    146a:	ec 01       	movw	r28, r24
	configASSERT( pxTimeOut );
    146c:	00 97       	sbiw	r24, 0x00	; 0
    146e:	39 f4       	brne	.+14     	; 0x147e <vTaskSetTimeOutState+0x18>
    1470:	61 ec       	ldi	r22, 0xC1	; 193
    1472:	7b e0       	ldi	r23, 0x0B	; 11
    1474:	80 e0       	ldi	r24, 0x00	; 0
    1476:	90 e0       	ldi	r25, 0x00	; 0
    1478:	42 e5       	ldi	r20, 0x52	; 82
    147a:	52 e0       	ldi	r21, 0x02	; 2
    147c:	d3 d6       	rcall	.+3494   	; 0x2224 <vAssertCalled>
    147e:	80 91 4c 20 	lds	r24, 0x204C
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1482:	88 83       	st	Y, r24
    1484:	80 91 48 20 	lds	r24, 0x2048
	pxTimeOut->xTimeOnEntering = xTickCount;
    1488:	90 91 49 20 	lds	r25, 0x2049
    148c:	9a 83       	std	Y+2, r25	; 0x02
    148e:	89 83       	std	Y+1, r24	; 0x01
    1490:	df 91       	pop	r29
}
    1492:	cf 91       	pop	r28
    1494:	08 95       	ret

00001496 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1496:	0f 93       	push	r16
    1498:	1f 93       	push	r17
    149a:	cf 93       	push	r28
    149c:	df 93       	push	r29
    149e:	ec 01       	movw	r28, r24
    14a0:	8b 01       	movw	r16, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
    14a2:	00 97       	sbiw	r24, 0x00	; 0
    14a4:	39 f4       	brne	.+14     	; 0x14b4 <xTaskCheckForTimeOut+0x1e>
    14a6:	6b ec       	ldi	r22, 0xCB	; 203
    14a8:	7b e0       	ldi	r23, 0x0B	; 11
    14aa:	80 e0       	ldi	r24, 0x00	; 0
    14ac:	90 e0       	ldi	r25, 0x00	; 0
    14ae:	42 e5       	ldi	r20, 0x52	; 82
    14b0:	52 e0       	ldi	r21, 0x02	; 2
    14b2:	b8 d6       	rcall	.+3440   	; 0x2224 <vAssertCalled>
    14b4:	01 15       	cp	r16, r1
	configASSERT( pxTicksToWait );
    14b6:	11 05       	cpc	r17, r1
    14b8:	39 f4       	brne	.+14     	; 0x14c8 <xTaskCheckForTimeOut+0x32>
    14ba:	6c ec       	ldi	r22, 0xCC	; 204
    14bc:	7b e0       	ldi	r23, 0x0B	; 11
    14be:	80 e0       	ldi	r24, 0x00	; 0
    14c0:	90 e0       	ldi	r25, 0x00	; 0
    14c2:	42 e5       	ldi	r20, 0x52	; 82
    14c4:	52 e0       	ldi	r21, 0x02	; 2
    14c6:	ae d6       	rcall	.+3420   	; 0x2224 <vAssertCalled>
    14c8:	0f b6       	in	r0, 0x3f	; 63
    14ca:	f8 94       	cli

	taskENTER_CRITICAL();
    14cc:	0f 92       	push	r0
    14ce:	40 91 48 20 	lds	r20, 0x2048
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    14d2:	50 91 49 20 	lds	r21, 0x2049
    14d6:	90 91 4c 20 	lds	r25, 0x204C
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    14da:	88 81       	ld	r24, Y
    14dc:	98 17       	cp	r25, r24
    14de:	29 f0       	breq	.+10     	; 0x14ea <xTaskCheckForTimeOut+0x54>
    14e0:	89 81       	ldd	r24, Y+1	; 0x01
    14e2:	9a 81       	ldd	r25, Y+2	; 0x02
    14e4:	48 17       	cp	r20, r24
    14e6:	59 07       	cpc	r21, r25
    14e8:	a8 f4       	brcc	.+42     	; 0x1514 <xTaskCheckForTimeOut+0x7e>
    14ea:	29 81       	ldd	r18, Y+1	; 0x01
    14ec:	3a 81       	ldd	r19, Y+2	; 0x02
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    14ee:	f8 01       	movw	r30, r16
    14f0:	60 81       	ld	r22, Z
    14f2:	71 81       	ldd	r23, Z+1	; 0x01
    14f4:	ca 01       	movw	r24, r20
    14f6:	82 1b       	sub	r24, r18
    14f8:	93 0b       	sbc	r25, r19
    14fa:	86 17       	cp	r24, r22
    14fc:	97 07       	cpc	r25, r23
    14fe:	50 f4       	brcc	.+20     	; 0x1514 <xTaskCheckForTimeOut+0x7e>
    1500:	24 1b       	sub	r18, r20
    1502:	35 0b       	sbc	r19, r21
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    1504:	26 0f       	add	r18, r22
    1506:	37 1f       	adc	r19, r23
    1508:	31 83       	std	Z+1, r19	; 0x01
    150a:	20 83       	st	Z, r18
    150c:	ce 01       	movw	r24, r28
    150e:	ab df       	rcall	.-170    	; 0x1466 <vTaskSetTimeOutState>
			vTaskSetTimeOutState( pxTimeOut );
    1510:	80 e0       	ldi	r24, 0x00	; 0
    1512:	01 c0       	rjmp	.+2      	; 0x1516 <xTaskCheckForTimeOut+0x80>
    1514:	81 e0       	ldi	r24, 0x01	; 1
    1516:	0f 90       	pop	r0
    1518:	0f be       	out	0x3f, r0	; 63
    151a:	df 91       	pop	r29
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    151c:	cf 91       	pop	r28
    151e:	1f 91       	pop	r17

	return xReturn;
}
    1520:	0f 91       	pop	r16
    1522:	08 95       	ret

00001524 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    1524:	0f 93       	push	r16
    1526:	1f 93       	push	r17
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1528:	80 91 45 20 	lds	r24, 0x2045
    152c:	88 23       	and	r24, r24
    152e:	21 f0       	breq	.+8      	; 0x1538 <vTaskSwitchContext+0x14>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1530:	81 e0       	ldi	r24, 0x01	; 1
    1532:	80 93 47 20 	sts	0x2047, r24
    1536:	3a c0       	rjmp	.+116    	; 0x15ac <vTaskSwitchContext+0x88>
	}
	else
	{
		xYieldPending = pdFALSE;
    1538:	10 92 47 20 	sts	0x2047, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    153c:	10 91 46 20 	lds	r17, 0x2046
    1540:	09 e0       	ldi	r16, 0x09	; 9
    1542:	0a c0       	rjmp	.+20     	; 0x1558 <vTaskSwitchContext+0x34>
    1544:	11 23       	and	r17, r17
    1546:	39 f4       	brne	.+14     	; 0x1556 <vTaskSwitchContext+0x32>
    1548:	66 ef       	ldi	r22, 0xF6	; 246
    154a:	7a e0       	ldi	r23, 0x0A	; 10
    154c:	80 e0       	ldi	r24, 0x00	; 0
    154e:	90 e0       	ldi	r25, 0x00	; 0
    1550:	42 e5       	ldi	r20, 0x52	; 82
    1552:	52 e0       	ldi	r21, 0x02	; 2
    1554:	67 d6       	rcall	.+3278   	; 0x2224 <vAssertCalled>
    1556:	11 50       	subi	r17, 0x01	; 1
    1558:	10 9f       	mul	r17, r16
    155a:	d0 01       	movw	r26, r0
    155c:	11 24       	eor	r1, r1
    155e:	ad 5a       	subi	r26, 0xAD	; 173
    1560:	bf 4d       	sbci	r27, 0xDF	; 223
    1562:	8c 91       	ld	r24, X
    1564:	88 23       	and	r24, r24
    1566:	71 f3       	breq	.-36     	; 0x1544 <vTaskSwitchContext+0x20>
    1568:	11 96       	adiw	r26, 0x01	; 1
    156a:	ed 91       	ld	r30, X+
    156c:	fc 91       	ld	r31, X
    156e:	12 97       	sbiw	r26, 0x02	; 2
    1570:	02 80       	ldd	r0, Z+2	; 0x02
    1572:	f3 81       	ldd	r31, Z+3	; 0x03
    1574:	e0 2d       	mov	r30, r0
    1576:	12 96       	adiw	r26, 0x02	; 2
    1578:	fc 93       	st	X, r31
    157a:	ee 93       	st	-X, r30
    157c:	11 97       	sbiw	r26, 0x01	; 1
    157e:	cd 01       	movw	r24, r26
    1580:	03 96       	adiw	r24, 0x03	; 3
    1582:	e8 17       	cp	r30, r24
    1584:	f9 07       	cpc	r31, r25
    1586:	31 f4       	brne	.+12     	; 0x1594 <vTaskSwitchContext+0x70>
    1588:	82 81       	ldd	r24, Z+2	; 0x02
    158a:	93 81       	ldd	r25, Z+3	; 0x03
    158c:	12 96       	adiw	r26, 0x02	; 2
    158e:	9c 93       	st	X, r25
    1590:	8e 93       	st	-X, r24
    1592:	11 97       	sbiw	r26, 0x01	; 1
    1594:	11 96       	adiw	r26, 0x01	; 1
    1596:	ed 91       	ld	r30, X+
    1598:	fc 91       	ld	r31, X
    159a:	12 97       	sbiw	r26, 0x02	; 2
    159c:	86 81       	ldd	r24, Z+6	; 0x06
    159e:	97 81       	ldd	r25, Z+7	; 0x07
    15a0:	90 93 44 20 	sts	0x2044, r25
    15a4:	80 93 43 20 	sts	0x2043, r24
    15a8:	10 93 46 20 	sts	0x2046, r17
    15ac:	1f 91       	pop	r17
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    15ae:	0f 91       	pop	r16
    15b0:	08 95       	ret

000015b2 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    15b2:	0f 93       	push	r16
    15b4:	1f 93       	push	r17
    15b6:	cf 93       	push	r28
    15b8:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    15ba:	dc 01       	movw	r26, r24
    15bc:	15 96       	adiw	r26, 0x05	; 5
    15be:	ed 91       	ld	r30, X+
    15c0:	fc 91       	ld	r31, X
    15c2:	16 97       	sbiw	r26, 0x06	; 6
    15c4:	c6 81       	ldd	r28, Z+6	; 0x06
    15c6:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
    15c8:	20 97       	sbiw	r28, 0x00	; 0
    15ca:	39 f4       	brne	.+14     	; 0x15da <xTaskRemoveFromEventList+0x28>
    15cc:	61 e6       	ldi	r22, 0x61	; 97
    15ce:	7b e0       	ldi	r23, 0x0B	; 11
    15d0:	80 e0       	ldi	r24, 0x00	; 0
    15d2:	90 e0       	ldi	r25, 0x00	; 0
    15d4:	42 e5       	ldi	r20, 0x52	; 82
    15d6:	52 e0       	ldi	r21, 0x02	; 2
    15d8:	25 d6       	rcall	.+3146   	; 0x2224 <vAssertCalled>
    15da:	8e 01       	movw	r16, r28
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    15dc:	04 5f       	subi	r16, 0xF4	; 244
    15de:	1f 4f       	sbci	r17, 0xFF	; 255
    15e0:	c8 01       	movw	r24, r16
    15e2:	20 db       	rcall	.-2496   	; 0xc24 <uxListRemove>
    15e4:	80 91 45 20 	lds	r24, 0x2045

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    15e8:	88 23       	and	r24, r24
    15ea:	99 f4       	brne	.+38     	; 0x1612 <xTaskRemoveFromEventList+0x60>
    15ec:	8e 01       	movw	r16, r28
    15ee:	0e 5f       	subi	r16, 0xFE	; 254
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    15f0:	1f 4f       	sbci	r17, 0xFF	; 255
    15f2:	c8 01       	movw	r24, r16
    15f4:	17 db       	rcall	.-2514   	; 0xc24 <uxListRemove>
    15f6:	9e 89       	ldd	r25, Y+22	; 0x16
    15f8:	80 91 46 20 	lds	r24, 0x2046
		prvAddTaskToReadyList( pxUnblockedTCB );
    15fc:	89 17       	cp	r24, r25
    15fe:	10 f4       	brcc	.+4      	; 0x1604 <xTaskRemoveFromEventList+0x52>
    1600:	90 93 46 20 	sts	0x2046, r25
    1604:	89 e0       	ldi	r24, 0x09	; 9
    1606:	98 9f       	mul	r25, r24
    1608:	c0 01       	movw	r24, r0
    160a:	11 24       	eor	r1, r1
    160c:	8d 5a       	subi	r24, 0xAD	; 173
    160e:	9f 4d       	sbci	r25, 0xDF	; 223
    1610:	02 c0       	rjmp	.+4      	; 0x1616 <xTaskRemoveFromEventList+0x64>
    1612:	8d e8       	ldi	r24, 0x8D	; 141
    1614:	90 e2       	ldi	r25, 0x20	; 32
    1616:	b8 01       	movw	r22, r16
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1618:	b4 da       	rcall	.-2712   	; 0xb82 <vListInsertEnd>
    161a:	e0 91 43 20 	lds	r30, 0x2043
    161e:	f0 91 44 20 	lds	r31, 0x2044
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1622:	9e 89       	ldd	r25, Y+22	; 0x16
    1624:	86 89       	ldd	r24, Z+22	; 0x16
    1626:	89 17       	cp	r24, r25
    1628:	10 f0       	brcs	.+4      	; 0x162e <xTaskRemoveFromEventList+0x7c>
    162a:	80 e0       	ldi	r24, 0x00	; 0
    162c:	03 c0       	rjmp	.+6      	; 0x1634 <xTaskRemoveFromEventList+0x82>
    162e:	81 e0       	ldi	r24, 0x01	; 1
    1630:	80 93 47 20 	sts	0x2047, r24
    1634:	df 91       	pop	r29
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1636:	cf 91       	pop	r28
    1638:	1f 91       	pop	r17
    163a:	0f 91       	pop	r16
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    163c:	08 95       	ret

0000163e <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    163e:	cf 92       	push	r12
    1640:	df 92       	push	r13
    1642:	ef 92       	push	r14
    1644:	ff 92       	push	r15
    1646:	0f 93       	push	r16
    1648:	1f 93       	push	r17
    164a:	cf 93       	push	r28
    164c:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    164e:	80 91 45 20 	lds	r24, 0x2045
    1652:	88 23       	and	r24, r24
    1654:	09 f0       	breq	.+2      	; 0x1658 <xTaskIncrementTick+0x1a>
    1656:	b1 c0       	rjmp	.+354    	; 0x17ba <xTaskIncrementTick+0x17c>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    1658:	00 91 48 20 	lds	r16, 0x2048
    165c:	10 91 49 20 	lds	r17, 0x2049
    1660:	0f 5f       	subi	r16, 0xFF	; 255
    1662:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    1664:	10 93 49 20 	sts	0x2049, r17
    1668:	00 93 48 20 	sts	0x2048, r16

		if( xConstTickCount == ( TickType_t ) 0U )
    166c:	01 15       	cp	r16, r1
    166e:	11 05       	cpc	r17, r1
    1670:	e9 f5       	brne	.+122    	; 0x16ec <xTaskIncrementTick+0xae>
		{
			taskSWITCH_DELAYED_LISTS();
    1672:	e0 91 89 20 	lds	r30, 0x2089
    1676:	f0 91 8a 20 	lds	r31, 0x208A
    167a:	80 81       	ld	r24, Z
    167c:	88 23       	and	r24, r24
    167e:	39 f0       	breq	.+14     	; 0x168e <xTaskIncrementTick+0x50>
    1680:	69 ed       	ldi	r22, 0xD9	; 217
    1682:	79 e0       	ldi	r23, 0x09	; 9
    1684:	80 e0       	ldi	r24, 0x00	; 0
    1686:	90 e0       	ldi	r25, 0x00	; 0
    1688:	42 e5       	ldi	r20, 0x52	; 82
    168a:	52 e0       	ldi	r21, 0x02	; 2
    168c:	cb d5       	rcall	.+2966   	; 0x2224 <vAssertCalled>
    168e:	20 91 89 20 	lds	r18, 0x2089
    1692:	30 91 8a 20 	lds	r19, 0x208A
    1696:	80 91 8b 20 	lds	r24, 0x208B
    169a:	90 91 8c 20 	lds	r25, 0x208C
    169e:	90 93 8a 20 	sts	0x208A, r25
    16a2:	80 93 89 20 	sts	0x2089, r24
    16a6:	30 93 8c 20 	sts	0x208C, r19
    16aa:	20 93 8b 20 	sts	0x208B, r18
    16ae:	80 91 4c 20 	lds	r24, 0x204C
    16b2:	8f 5f       	subi	r24, 0xFF	; 255
    16b4:	80 93 4c 20 	sts	0x204C, r24
    16b8:	e0 91 89 20 	lds	r30, 0x2089

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    16bc:	f0 91 8a 20 	lds	r31, 0x208A
    16c0:	80 81       	ld	r24, Z
    16c2:	88 23       	and	r24, r24
    16c4:	19 f4       	brne	.+6      	; 0x16cc <xTaskIncrementTick+0x8e>
    16c6:	8f ef       	ldi	r24, 0xFF	; 255
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    16c8:	9f ef       	ldi	r25, 0xFF	; 255
    16ca:	0c c0       	rjmp	.+24     	; 0x16e4 <xTaskIncrementTick+0xa6>
    16cc:	e0 91 89 20 	lds	r30, 0x2089
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    16d0:	f0 91 8a 20 	lds	r31, 0x208A
    16d4:	05 80       	ldd	r0, Z+5	; 0x05
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    16d6:	f6 81       	ldd	r31, Z+6	; 0x06
    16d8:	e0 2d       	mov	r30, r0
    16da:	06 80       	ldd	r0, Z+6	; 0x06
    16dc:	f7 81       	ldd	r31, Z+7	; 0x07
    16de:	e0 2d       	mov	r30, r0
    16e0:	82 81       	ldd	r24, Z+2	; 0x02
    16e2:	93 81       	ldd	r25, Z+3	; 0x03
    16e4:	90 93 4b 20 	sts	0x204B, r25
    16e8:	80 93 4a 20 	sts	0x204A, r24
    16ec:	80 91 4a 20 	lds	r24, 0x204A

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    16f0:	90 91 4b 20 	lds	r25, 0x204B
    16f4:	08 17       	cp	r16, r24
    16f6:	19 07       	cpc	r17, r25
    16f8:	08 f4       	brcc	.+2      	; 0x16fc <xTaskIncrementTick+0xbe>
    16fa:	48 c0       	rjmp	.+144    	; 0x178c <xTaskIncrementTick+0x14e>
    16fc:	dd 24       	eor	r13, r13
    16fe:	49 e0       	ldi	r20, 0x09	; 9
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    1700:	c4 2e       	mov	r12, r20
    1702:	e0 91 89 20 	lds	r30, 0x2089
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1706:	f0 91 8a 20 	lds	r31, 0x208A
    170a:	80 81       	ld	r24, Z
    170c:	88 23       	and	r24, r24
    170e:	19 f4       	brne	.+6      	; 0x1716 <xTaskIncrementTick+0xd8>
    1710:	8f ef       	ldi	r24, 0xFF	; 255
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1712:	9f ef       	ldi	r25, 0xFF	; 255
    1714:	0e c0       	rjmp	.+28     	; 0x1732 <xTaskIncrementTick+0xf4>
    1716:	e0 91 89 20 	lds	r30, 0x2089
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    171a:	f0 91 8a 20 	lds	r31, 0x208A
    171e:	05 80       	ldd	r0, Z+5	; 0x05
    1720:	f6 81       	ldd	r31, Z+6	; 0x06
    1722:	e0 2d       	mov	r30, r0
    1724:	c6 81       	ldd	r28, Z+6	; 0x06
    1726:	d7 81       	ldd	r29, Z+7	; 0x07
    1728:	8a 81       	ldd	r24, Y+2	; 0x02
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    172a:	9b 81       	ldd	r25, Y+3	; 0x03
    172c:	08 17       	cp	r16, r24

					if( xConstTickCount < xItemValue )
    172e:	19 07       	cpc	r17, r25
    1730:	28 f4       	brcc	.+10     	; 0x173c <xTaskIncrementTick+0xfe>
    1732:	90 93 4b 20 	sts	0x204B, r25
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    1736:	80 93 4a 20 	sts	0x204A, r24
    173a:	29 c0       	rjmp	.+82     	; 0x178e <xTaskIncrementTick+0x150>
    173c:	32 e0       	ldi	r19, 0x02	; 2
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    173e:	e3 2e       	mov	r14, r19
    1740:	f1 2c       	mov	r15, r1
    1742:	ec 0e       	add	r14, r28
    1744:	fd 1e       	adc	r15, r29
    1746:	c7 01       	movw	r24, r14
    1748:	6d da       	rcall	.-2854   	; 0xc24 <uxListRemove>
    174a:	8c 89       	ldd	r24, Y+20	; 0x14
    174c:	9d 89       	ldd	r25, Y+21	; 0x15

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    174e:	89 2b       	or	r24, r25
    1750:	19 f0       	breq	.+6      	; 0x1758 <xTaskIncrementTick+0x11a>
    1752:	ce 01       	movw	r24, r28
    1754:	0c 96       	adiw	r24, 0x0c	; 12
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1756:	66 da       	rcall	.-2868   	; 0xc24 <uxListRemove>
    1758:	9e 89       	ldd	r25, Y+22	; 0x16
    175a:	80 91 46 20 	lds	r24, 0x2046
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    175e:	89 17       	cp	r24, r25
    1760:	10 f4       	brcc	.+4      	; 0x1766 <xTaskIncrementTick+0x128>
    1762:	90 93 46 20 	sts	0x2046, r25
    1766:	9c 9d       	mul	r25, r12
    1768:	c0 01       	movw	r24, r0
    176a:	11 24       	eor	r1, r1
    176c:	8d 5a       	subi	r24, 0xAD	; 173
    176e:	9f 4d       	sbci	r25, 0xDF	; 223
    1770:	b7 01       	movw	r22, r14
    1772:	07 da       	rcall	.-3058   	; 0xb82 <vListInsertEnd>
    1774:	e0 91 43 20 	lds	r30, 0x2043
    1778:	f0 91 44 20 	lds	r31, 0x2044
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    177c:	9e 89       	ldd	r25, Y+22	; 0x16
    177e:	86 89       	ldd	r24, Z+22	; 0x16
    1780:	98 17       	cp	r25, r24
    1782:	08 f4       	brcc	.+2      	; 0x1786 <xTaskIncrementTick+0x148>
    1784:	be cf       	rjmp	.-132    	; 0x1702 <xTaskIncrementTick+0xc4>
    1786:	dd 24       	eor	r13, r13
    1788:	d3 94       	inc	r13
    178a:	bb cf       	rjmp	.-138    	; 0x1702 <xTaskIncrementTick+0xc4>
    178c:	dd 24       	eor	r13, r13
    178e:	e0 91 43 20 	lds	r30, 0x2043
    1792:	f0 91 44 20 	lds	r31, 0x2044
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1796:	86 89       	ldd	r24, Z+22	; 0x16
    1798:	90 e0       	ldi	r25, 0x00	; 0
    179a:	fc 01       	movw	r30, r24
    179c:	23 e0       	ldi	r18, 0x03	; 3
    179e:	ee 0f       	add	r30, r30
    17a0:	ff 1f       	adc	r31, r31
    17a2:	2a 95       	dec	r18
    17a4:	e1 f7       	brne	.-8      	; 0x179e <xTaskIncrementTick+0x160>
    17a6:	e8 0f       	add	r30, r24
    17a8:	f9 1f       	adc	r31, r25
    17aa:	ed 5a       	subi	r30, 0xAD	; 173
    17ac:	ff 4d       	sbci	r31, 0xDF	; 223
    17ae:	80 81       	ld	r24, Z
    17b0:	82 30       	cpi	r24, 0x02	; 2
    17b2:	48 f0       	brcs	.+18     	; 0x17c6 <xTaskIncrementTick+0x188>
    17b4:	dd 24       	eor	r13, r13
    17b6:	d3 94       	inc	r13
    17b8:	06 c0       	rjmp	.+12     	; 0x17c6 <xTaskIncrementTick+0x188>
    17ba:	80 91 4d 20 	lds	r24, 0x204D
    17be:	8f 5f       	subi	r24, 0xFF	; 255
    17c0:	80 93 4d 20 	sts	0x204D, r24
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    17c4:	dd 24       	eor	r13, r13
    17c6:	80 91 47 20 	lds	r24, 0x2047
    17ca:	88 23       	and	r24, r24
    17cc:	11 f0       	breq	.+4      	; 0x17d2 <xTaskIncrementTick+0x194>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    17ce:	dd 24       	eor	r13, r13
    17d0:	d3 94       	inc	r13
    17d2:	8d 2d       	mov	r24, r13
    17d4:	df 91       	pop	r29
    17d6:	cf 91       	pop	r28
    17d8:	1f 91       	pop	r17
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    17da:	0f 91       	pop	r16
    17dc:	ff 90       	pop	r15
    17de:	ef 90       	pop	r14
    17e0:	df 90       	pop	r13
    17e2:	cf 90       	pop	r12
    17e4:	08 95       	ret

000017e6 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    17e6:	ef 92       	push	r14
    17e8:	ff 92       	push	r15
    17ea:	0f 93       	push	r16
    17ec:	1f 93       	push	r17
    17ee:	cf 93       	push	r28
    17f0:	df 93       	push	r29
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
    17f2:	80 91 45 20 	lds	r24, 0x2045
    17f6:	88 23       	and	r24, r24
    17f8:	39 f4       	brne	.+14     	; 0x1808 <xTaskResumeAll+0x22>
    17fa:	68 ee       	ldi	r22, 0xE8	; 232
    17fc:	77 e0       	ldi	r23, 0x07	; 7
    17fe:	80 e0       	ldi	r24, 0x00	; 0
    1800:	90 e0       	ldi	r25, 0x00	; 0
    1802:	42 e5       	ldi	r20, 0x52	; 82
    1804:	52 e0       	ldi	r21, 0x02	; 2
    1806:	0e d5       	rcall	.+2588   	; 0x2224 <vAssertCalled>
    1808:	0f b6       	in	r0, 0x3f	; 63
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    180a:	f8 94       	cli
    180c:	0f 92       	push	r0
    180e:	80 91 45 20 	lds	r24, 0x2045
	{
		--uxSchedulerSuspended;
    1812:	81 50       	subi	r24, 0x01	; 1
    1814:	80 93 45 20 	sts	0x2045, r24
    1818:	80 91 45 20 	lds	r24, 0x2045

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    181c:	88 23       	and	r24, r24
    181e:	09 f0       	breq	.+2      	; 0x1822 <xTaskResumeAll+0x3c>
    1820:	68 c0       	rjmp	.+208    	; 0x18f2 <xTaskResumeAll+0x10c>
    1822:	80 91 4e 20 	lds	r24, 0x204E
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1826:	88 23       	and	r24, r24
    1828:	09 f4       	brne	.+2      	; 0x182c <xTaskResumeAll+0x46>
    182a:	63 c0       	rjmp	.+198    	; 0x18f2 <xTaskResumeAll+0x10c>
    182c:	c0 e0       	ldi	r28, 0x00	; 0
    182e:	d0 e0       	ldi	r29, 0x00	; 0
    1830:	59 e0       	ldi	r21, 0x09	; 9
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
    1832:	e5 2e       	mov	r14, r21
    1834:	ff 24       	eor	r15, r15

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    1836:	f3 94       	inc	r15
    1838:	26 c0       	rjmp	.+76     	; 0x1886 <xTaskResumeAll+0xa0>
    183a:	e0 91 92 20 	lds	r30, 0x2092
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    183e:	f0 91 93 20 	lds	r31, 0x2093
    1842:	c6 81       	ldd	r28, Z+6	; 0x06
    1844:	d7 81       	ldd	r29, Z+7	; 0x07
    1846:	ce 01       	movw	r24, r28
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1848:	0c 96       	adiw	r24, 0x0c	; 12
    184a:	ec d9       	rcall	.-3112   	; 0xc24 <uxListRemove>
    184c:	8e 01       	movw	r16, r28
    184e:	0e 5f       	subi	r16, 0xFE	; 254
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1850:	1f 4f       	sbci	r17, 0xFF	; 255
    1852:	c8 01       	movw	r24, r16
    1854:	e7 d9       	rcall	.-3122   	; 0xc24 <uxListRemove>
    1856:	9e 89       	ldd	r25, Y+22	; 0x16
    1858:	80 91 46 20 	lds	r24, 0x2046
					prvAddTaskToReadyList( pxTCB );
    185c:	89 17       	cp	r24, r25
    185e:	10 f4       	brcc	.+4      	; 0x1864 <xTaskResumeAll+0x7e>
    1860:	90 93 46 20 	sts	0x2046, r25
    1864:	9e 9d       	mul	r25, r14
    1866:	c0 01       	movw	r24, r0
    1868:	11 24       	eor	r1, r1
    186a:	8d 5a       	subi	r24, 0xAD	; 173
    186c:	9f 4d       	sbci	r25, 0xDF	; 223
    186e:	b8 01       	movw	r22, r16
    1870:	88 d9       	rcall	.-3312   	; 0xb82 <vListInsertEnd>
    1872:	e0 91 43 20 	lds	r30, 0x2043
    1876:	f0 91 44 20 	lds	r31, 0x2044

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    187a:	9e 89       	ldd	r25, Y+22	; 0x16
    187c:	86 89       	ldd	r24, Z+22	; 0x16
    187e:	98 17       	cp	r25, r24
    1880:	10 f0       	brcs	.+4      	; 0x1886 <xTaskResumeAll+0xa0>
    1882:	f0 92 47 20 	sts	0x2047, r15
    1886:	80 91 8d 20 	lds	r24, 0x208D
					{
						xYieldPending = pdTRUE;
    188a:	88 23       	and	r24, r24
    188c:	b1 f6       	brne	.-84     	; 0x183a <xTaskResumeAll+0x54>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    188e:	cd 2b       	or	r28, r29
    1890:	d1 f0       	breq	.+52     	; 0x18c6 <xTaskResumeAll+0xe0>
    1892:	e0 91 89 20 	lds	r30, 0x2089
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    1896:	f0 91 8a 20 	lds	r31, 0x208A

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    189a:	80 81       	ld	r24, Z
    189c:	88 23       	and	r24, r24
    189e:	19 f4       	brne	.+6      	; 0x18a6 <xTaskResumeAll+0xc0>
    18a0:	8f ef       	ldi	r24, 0xFF	; 255
    18a2:	9f ef       	ldi	r25, 0xFF	; 255
    18a4:	0c c0       	rjmp	.+24     	; 0x18be <xTaskResumeAll+0xd8>
    18a6:	e0 91 89 20 	lds	r30, 0x2089
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    18aa:	f0 91 8a 20 	lds	r31, 0x208A
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    18ae:	05 80       	ldd	r0, Z+5	; 0x05
    18b0:	f6 81       	ldd	r31, Z+6	; 0x06
    18b2:	e0 2d       	mov	r30, r0
    18b4:	06 80       	ldd	r0, Z+6	; 0x06
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    18b6:	f7 81       	ldd	r31, Z+7	; 0x07
    18b8:	e0 2d       	mov	r30, r0
    18ba:	82 81       	ldd	r24, Z+2	; 0x02
    18bc:	93 81       	ldd	r25, Z+3	; 0x03
    18be:	90 93 4b 20 	sts	0x204B, r25
    18c2:	80 93 4a 20 	sts	0x204A, r24
    18c6:	10 91 4d 20 	lds	r17, 0x204D
    18ca:	11 23       	and	r17, r17
    18cc:	51 f0       	breq	.+20     	; 0x18e2 <xTaskResumeAll+0xfc>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    18ce:	01 e0       	ldi	r16, 0x01	; 1
    18d0:	b6 de       	rcall	.-660    	; 0x163e <xTaskIncrementTick>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    18d2:	88 23       	and	r24, r24
    18d4:	11 f0       	breq	.+4      	; 0x18da <xTaskResumeAll+0xf4>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    18d6:	00 93 47 20 	sts	0x2047, r16

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    18da:	11 50       	subi	r17, 0x01	; 1
    18dc:	c9 f7       	brne	.-14     	; 0x18d0 <xTaskResumeAll+0xea>
    18de:	10 92 4d 20 	sts	0x204D, r1
							{
								xYieldPending = pdTRUE;
    18e2:	80 91 47 20 	lds	r24, 0x2047
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    18e6:	88 23       	and	r24, r24

						uxPendedTicks = 0;
    18e8:	21 f0       	breq	.+8      	; 0x18f2 <xTaskResumeAll+0x10c>
    18ea:	0e 94 41 04 	call	0x882	; 0x882 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    18ee:	81 e0       	ldi	r24, 0x01	; 1
    18f0:	01 c0       	rjmp	.+2      	; 0x18f4 <xTaskResumeAll+0x10e>
    18f2:	80 e0       	ldi	r24, 0x00	; 0
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    18f4:	0f 90       	pop	r0
    18f6:	0f be       	out	0x3f, r0	; 63
    18f8:	df 91       	pop	r29
    18fa:	cf 91       	pop	r28
    18fc:	1f 91       	pop	r17
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    18fe:	0f 91       	pop	r16
    1900:	ff 90       	pop	r15

	return xAlreadyYielded;
}
    1902:	ef 90       	pop	r14
    1904:	08 95       	ret

00001906 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1906:	80 91 53 20 	lds	r24, 0x2053
    190a:	82 30       	cpi	r24, 0x02	; 2
    190c:	18 f0       	brcs	.+6      	; 0x1914 <prvIdleTask+0xe>
			{
				taskYIELD();
    190e:	0e 94 41 04 	call	0x882	; 0x882 <vPortYield>
    1912:	f9 cf       	rjmp	.-14     	; 0x1906 <prvIdleTask>
    1914:	ff cf       	rjmp	.-2      	; 0x1914 <prvIdleTask+0xe>

00001916 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    1916:	0f 93       	push	r16
    1918:	1f 93       	push	r17
    191a:	cf 93       	push	r28
    191c:	df 93       	push	r29
    191e:	ec 01       	movw	r28, r24
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    1920:	00 91 48 20 	lds	r16, 0x2048
    1924:	10 91 49 20 	lds	r17, 0x2049
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1928:	80 91 43 20 	lds	r24, 0x2043
    192c:	90 91 44 20 	lds	r25, 0x2044
    1930:	02 96       	adiw	r24, 0x02	; 2
    1932:	78 d9       	rcall	.-3344   	; 0xc24 <uxListRemove>
    1934:	c0 0f       	add	r28, r16
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    1936:	d1 1f       	adc	r29, r17
    1938:	e0 91 43 20 	lds	r30, 0x2043

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    193c:	f0 91 44 20 	lds	r31, 0x2044
    1940:	d3 83       	std	Z+3, r29	; 0x03
    1942:	c2 83       	std	Z+2, r28	; 0x02
    1944:	c0 17       	cp	r28, r16

		if( xTimeToWake < xConstTickCount )
    1946:	d1 07       	cpc	r29, r17
    1948:	60 f4       	brcc	.+24     	; 0x1962 <prvAddCurrentTaskToDelayedList+0x4c>
    194a:	80 91 8b 20 	lds	r24, 0x208B
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    194e:	90 91 8c 20 	lds	r25, 0x208C
    1952:	60 91 43 20 	lds	r22, 0x2043
    1956:	70 91 44 20 	lds	r23, 0x2044
    195a:	6e 5f       	subi	r22, 0xFE	; 254
    195c:	7f 4f       	sbci	r23, 0xFF	; 255
    195e:	30 d9       	rcall	.-3488   	; 0xbc0 <vListInsert>
    1960:	16 c0       	rjmp	.+44     	; 0x198e <prvAddCurrentTaskToDelayedList+0x78>
    1962:	80 91 89 20 	lds	r24, 0x2089
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1966:	90 91 8a 20 	lds	r25, 0x208A
    196a:	60 91 43 20 	lds	r22, 0x2043
    196e:	70 91 44 20 	lds	r23, 0x2044
    1972:	6e 5f       	subi	r22, 0xFE	; 254
    1974:	7f 4f       	sbci	r23, 0xFF	; 255
    1976:	24 d9       	rcall	.-3512   	; 0xbc0 <vListInsert>
    1978:	80 91 4a 20 	lds	r24, 0x204A
    197c:	90 91 4b 20 	lds	r25, 0x204B

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    1980:	c8 17       	cp	r28, r24
    1982:	d9 07       	cpc	r29, r25
    1984:	20 f4       	brcc	.+8      	; 0x198e <prvAddCurrentTaskToDelayedList+0x78>
    1986:	d0 93 4b 20 	sts	0x204B, r29
    198a:	c0 93 4a 20 	sts	0x204A, r28
			{
				xNextTaskUnblockTime = xTimeToWake;
    198e:	df 91       	pop	r29
    1990:	cf 91       	pop	r28
    1992:	1f 91       	pop	r17

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1994:	0f 91       	pop	r16
    1996:	08 95       	ret

00001998 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    1998:	cf 93       	push	r28
    199a:	df 93       	push	r29
    199c:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    199e:	00 97       	sbiw	r24, 0x00	; 0
    19a0:	b1 f0       	breq	.+44     	; 0x19ce <vTaskDelay+0x36>
		{
			configASSERT( uxSchedulerSuspended == 0 );
    19a2:	80 91 45 20 	lds	r24, 0x2045
    19a6:	88 23       	and	r24, r24
    19a8:	39 f0       	breq	.+14     	; 0x19b8 <vTaskDelay+0x20>
    19aa:	6f ec       	ldi	r22, 0xCF	; 207
    19ac:	74 e0       	ldi	r23, 0x04	; 4
    19ae:	80 e0       	ldi	r24, 0x00	; 0
    19b0:	90 e0       	ldi	r25, 0x00	; 0
    19b2:	42 e5       	ldi	r20, 0x52	; 82
    19b4:	52 e0       	ldi	r21, 0x02	; 2
    19b6:	36 d4       	rcall	.+2156   	; 0x2224 <vAssertCalled>
    19b8:	80 91 45 20 	lds	r24, 0x2045
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    19bc:	8f 5f       	subi	r24, 0xFF	; 255
    19be:	80 93 45 20 	sts	0x2045, r24
    19c2:	ce 01       	movw	r24, r28
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    19c4:	60 e0       	ldi	r22, 0x00	; 0
    19c6:	a7 df       	rcall	.-178    	; 0x1916 <prvAddCurrentTaskToDelayedList>
    19c8:	0e df       	rcall	.-484    	; 0x17e6 <xTaskResumeAll>
    19ca:	88 23       	and	r24, r24
			}
			xAlreadyYielded = xTaskResumeAll();
    19cc:	11 f4       	brne	.+4      	; 0x19d2 <vTaskDelay+0x3a>
    19ce:	0e 94 41 04 	call	0x882	; 0x882 <vPortYield>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    19d2:	df 91       	pop	r29
		{
			portYIELD_WITHIN_API();
    19d4:	cf 91       	pop	r28
    19d6:	08 95       	ret

000019d8 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    19d8:	0f 93       	push	r16
    19da:	1f 93       	push	r17
    19dc:	cf 93       	push	r28
    19de:	df 93       	push	r29
    19e0:	ec 01       	movw	r28, r24
    19e2:	8b 01       	movw	r16, r22
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
    19e4:	00 97       	sbiw	r24, 0x00	; 0
    19e6:	39 f4       	brne	.+14     	; 0x19f6 <vTaskDelayUntil+0x1e>
    19e8:	69 e7       	ldi	r22, 0x79	; 121
    19ea:	74 e0       	ldi	r23, 0x04	; 4
    19ec:	80 e0       	ldi	r24, 0x00	; 0
    19ee:	90 e0       	ldi	r25, 0x00	; 0
    19f0:	42 e5       	ldi	r20, 0x52	; 82
    19f2:	52 e0       	ldi	r21, 0x02	; 2
    19f4:	17 d4       	rcall	.+2094   	; 0x2224 <vAssertCalled>
    19f6:	01 15       	cp	r16, r1
		configASSERT( ( xTimeIncrement > 0U ) );
    19f8:	11 05       	cpc	r17, r1
    19fa:	39 f4       	brne	.+14     	; 0x1a0a <vTaskDelayUntil+0x32>
    19fc:	6a e7       	ldi	r22, 0x7A	; 122
    19fe:	74 e0       	ldi	r23, 0x04	; 4
    1a00:	80 e0       	ldi	r24, 0x00	; 0
    1a02:	90 e0       	ldi	r25, 0x00	; 0
    1a04:	42 e5       	ldi	r20, 0x52	; 82
    1a06:	52 e0       	ldi	r21, 0x02	; 2
    1a08:	0d d4       	rcall	.+2074   	; 0x2224 <vAssertCalled>
    1a0a:	80 91 45 20 	lds	r24, 0x2045
		configASSERT( uxSchedulerSuspended == 0 );
    1a0e:	88 23       	and	r24, r24
    1a10:	39 f0       	breq	.+14     	; 0x1a20 <vTaskDelayUntil+0x48>
    1a12:	6b e7       	ldi	r22, 0x7B	; 123
    1a14:	74 e0       	ldi	r23, 0x04	; 4
    1a16:	80 e0       	ldi	r24, 0x00	; 0
    1a18:	90 e0       	ldi	r25, 0x00	; 0
    1a1a:	42 e5       	ldi	r20, 0x52	; 82
    1a1c:	52 e0       	ldi	r21, 0x02	; 2
    1a1e:	02 d4       	rcall	.+2052   	; 0x2224 <vAssertCalled>
    1a20:	80 91 45 20 	lds	r24, 0x2045
    1a24:	8f 5f       	subi	r24, 0xFF	; 255
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    1a26:	80 93 45 20 	sts	0x2045, r24
    1a2a:	40 91 48 20 	lds	r20, 0x2048
    1a2e:	50 91 49 20 	lds	r21, 0x2049

		vTaskSuspendAll();
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1a32:	28 81       	ld	r18, Y
    1a34:	39 81       	ldd	r19, Y+1	; 0x01
    1a36:	b9 01       	movw	r22, r18

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1a38:	60 0f       	add	r22, r16
    1a3a:	71 1f       	adc	r23, r17
    1a3c:	42 17       	cp	r20, r18
    1a3e:	53 07       	cpc	r21, r19
    1a40:	28 f4       	brcc	.+10     	; 0x1a4c <vTaskDelayUntil+0x74>

			if( xConstTickCount < *pxPreviousWakeTime )
    1a42:	62 17       	cp	r22, r18
    1a44:	73 07       	cpc	r23, r19
    1a46:	28 f0       	brcs	.+10     	; 0x1a52 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1a48:	80 e0       	ldi	r24, 0x00	; 0
    1a4a:	08 c0       	rjmp	.+16     	; 0x1a5c <vTaskDelayUntil+0x84>
    1a4c:	62 17       	cp	r22, r18
    1a4e:	73 07       	cpc	r23, r19
    1a50:	20 f0       	brcs	.+8      	; 0x1a5a <vTaskDelayUntil+0x82>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1a52:	80 e0       	ldi	r24, 0x00	; 0
    1a54:	46 17       	cp	r20, r22
    1a56:	57 07       	cpc	r21, r23
    1a58:	08 f4       	brcc	.+2      	; 0x1a5c <vTaskDelayUntil+0x84>
    1a5a:	81 e0       	ldi	r24, 0x01	; 1
    1a5c:	79 83       	std	Y+1, r23	; 0x01
    1a5e:	68 83       	st	Y, r22
    1a60:	88 23       	and	r24, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1a62:	29 f0       	breq	.+10     	; 0x1a6e <vTaskDelayUntil+0x96>
    1a64:	cb 01       	movw	r24, r22

			if( xShouldDelay != pdFALSE )
    1a66:	84 1b       	sub	r24, r20
    1a68:	95 0b       	sbc	r25, r21
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    1a6a:	60 e0       	ldi	r22, 0x00	; 0
    1a6c:	54 df       	rcall	.-344    	; 0x1916 <prvAddCurrentTaskToDelayedList>
    1a6e:	bb de       	rcall	.-650    	; 0x17e6 <xTaskResumeAll>
    1a70:	88 23       	and	r24, r24
    1a72:	11 f4       	brne	.+4      	; 0x1a78 <vTaskDelayUntil+0xa0>
    1a74:	0e 94 41 04 	call	0x882	; 0x882 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1a78:	df 91       	pop	r29

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1a7a:	cf 91       	pop	r28
    1a7c:	1f 91       	pop	r17
		{
			portYIELD_WITHIN_API();
    1a7e:	0f 91       	pop	r16
    1a80:	08 95       	ret

00001a82 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1a82:	0f 93       	push	r16
    1a84:	1f 93       	push	r17
    1a86:	cf 93       	push	r28
    1a88:	df 93       	push	r29
    1a8a:	ec 01       	movw	r28, r24
    1a8c:	8b 01       	movw	r16, r22
	configASSERT( pxEventList );
    1a8e:	00 97       	sbiw	r24, 0x00	; 0
    1a90:	39 f4       	brne	.+14     	; 0x1aa0 <vTaskPlaceOnEventList+0x1e>
    1a92:	66 e0       	ldi	r22, 0x06	; 6
    1a94:	7b e0       	ldi	r23, 0x0B	; 11
    1a96:	80 e0       	ldi	r24, 0x00	; 0
    1a98:	90 e0       	ldi	r25, 0x00	; 0
    1a9a:	42 e5       	ldi	r20, 0x52	; 82
    1a9c:	52 e0       	ldi	r21, 0x02	; 2
    1a9e:	c2 d3       	rcall	.+1924   	; 0x2224 <vAssertCalled>
    1aa0:	60 91 43 20 	lds	r22, 0x2043

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1aa4:	70 91 44 20 	lds	r23, 0x2044
    1aa8:	64 5f       	subi	r22, 0xF4	; 244
    1aaa:	7f 4f       	sbci	r23, 0xFF	; 255
    1aac:	ce 01       	movw	r24, r28
    1aae:	88 d8       	rcall	.-3824   	; 0xbc0 <vListInsert>
    1ab0:	c8 01       	movw	r24, r16
    1ab2:	61 e0       	ldi	r22, 0x01	; 1

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1ab4:	30 df       	rcall	.-416    	; 0x1916 <prvAddCurrentTaskToDelayedList>
    1ab6:	df 91       	pop	r29
    1ab8:	cf 91       	pop	r28
    1aba:	1f 91       	pop	r17
}
    1abc:	0f 91       	pop	r16
    1abe:	08 95       	ret

00001ac0 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1ac0:	4f 92       	push	r4
    1ac2:	5f 92       	push	r5
    1ac4:	6f 92       	push	r6
    1ac6:	7f 92       	push	r7
    1ac8:	8f 92       	push	r8
    1aca:	9f 92       	push	r9
    1acc:	af 92       	push	r10
    1ace:	bf 92       	push	r11
    1ad0:	cf 92       	push	r12
    1ad2:	df 92       	push	r13
    1ad4:	ef 92       	push	r14
    1ad6:	ff 92       	push	r15
    1ad8:	0f 93       	push	r16
    1ada:	1f 93       	push	r17
    1adc:	cf 93       	push	r28
    1ade:	df 93       	push	r29
    1ae0:	2c 01       	movw	r4, r24
    1ae2:	16 2f       	mov	r17, r22
    1ae4:	97 2e       	mov	r9, r23
    1ae6:	6a 01       	movw	r12, r20
    1ae8:	39 01       	movw	r6, r18
    1aea:	57 01       	movw	r10, r14
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1aec:	ca 01       	movw	r24, r20
    1aee:	0e 94 ac 04 	call	0x958	; 0x958 <pvPortMalloc>
    1af2:	7c 01       	movw	r14, r24

			if( pxStack != NULL )
    1af4:	00 97       	sbiw	r24, 0x00	; 0
    1af6:	99 f0       	breq	.+38     	; 0x1b1e <xTaskCreate+0x5e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    1af8:	86 e2       	ldi	r24, 0x26	; 38
    1afa:	90 e0       	ldi	r25, 0x00	; 0
    1afc:	0e 94 ac 04 	call	0x958	; 0x958 <pvPortMalloc>
    1b00:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
    1b02:	00 97       	sbiw	r24, 0x00	; 0
    1b04:	49 f0       	breq	.+18     	; 0x1b18 <xTaskCreate+0x58>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    1b06:	f8 8e       	std	Y+24, r15	; 0x18
    1b08:	ef 8a       	std	Y+23, r14	; 0x17
    1b0a:	81 2f       	mov	r24, r17
    1b0c:	99 2d       	mov	r25, r9
    1b0e:	9c 01       	movw	r18, r24
    1b10:	f9 01       	movw	r30, r18
    1b12:	de 01       	movw	r26, r28
    1b14:	90 e0       	ldi	r25, 0x00	; 0
    1b16:	05 c0       	rjmp	.+10     	; 0x1b22 <xTaskCreate+0x62>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    1b18:	c7 01       	movw	r24, r14
    1b1a:	0e 94 a1 04 	call	0x942	; 0x942 <vPortFree>
    1b1e:	8f ef       	ldi	r24, 0xFF	; 255
    1b20:	b1 c0       	rjmp	.+354    	; 0x1c84 <xTaskCreate+0x1c4>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1b22:	80 81       	ld	r24, Z
    1b24:	59 96       	adiw	r26, 0x19	; 25
    1b26:	8c 93       	st	X, r24
    1b28:	59 97       	sbiw	r26, 0x19	; 25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1b2a:	80 81       	ld	r24, Z
    1b2c:	88 23       	and	r24, r24
    1b2e:	29 f0       	breq	.+10     	; 0x1b3a <xTaskCreate+0x7a>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    1b30:	9f 5f       	subi	r25, 0xFF	; 255
    1b32:	31 96       	adiw	r30, 0x01	; 1
    1b34:	11 96       	adiw	r26, 0x01	; 1
    1b36:	98 30       	cpi	r25, 0x08	; 8
    1b38:	a1 f7       	brne	.-24     	; 0x1b22 <xTaskCreate+0x62>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1b3a:	18 a2       	std	Y+32, r1	; 0x20
    1b3c:	04 30       	cpi	r16, 0x04	; 4
    1b3e:	08 f0       	brcs	.+2      	; 0x1b42 <xTaskCreate+0x82>
    1b40:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    1b42:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    1b44:	72 e0       	ldi	r23, 0x02	; 2
    1b46:	87 2e       	mov	r8, r23
    1b48:	91 2c       	mov	r9, r1
    1b4a:	8c 0e       	add	r8, r28
    1b4c:	9d 1e       	adc	r9, r29
    1b4e:	c4 01       	movw	r24, r8
    1b50:	14 d8       	rcall	.-4056   	; 0xb7a <vListInitialiseItem>
    1b52:	ce 01       	movw	r24, r28
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    1b54:	0c 96       	adiw	r24, 0x0c	; 12
    1b56:	11 d8       	rcall	.-4062   	; 0xb7a <vListInitialiseItem>
    1b58:	d9 87       	std	Y+9, r29	; 0x09
    1b5a:	c8 87       	std	Y+8, r28	; 0x08

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    1b5c:	84 e0       	ldi	r24, 0x04	; 4
    1b5e:	90 e0       	ldi	r25, 0x00	; 0

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1b60:	80 1b       	sub	r24, r16
    1b62:	91 09       	sbc	r25, r1
    1b64:	9d 87       	std	Y+13, r25	; 0x0d
    1b66:	8c 87       	std	Y+12, r24	; 0x0c
    1b68:	db 8b       	std	Y+19, r29	; 0x13
    1b6a:	ca 8b       	std	Y+18, r28	; 0x12
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    1b6c:	19 a2       	std	Y+33, r1	; 0x21
    1b6e:	1a a2       	std	Y+34, r1	; 0x22
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    1b70:	1b a2       	std	Y+35, r1	; 0x23
    1b72:	1c a2       	std	Y+36, r1	; 0x24
    1b74:	1d a2       	std	Y+37, r1	; 0x25
    1b76:	08 94       	sec
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1b78:	c1 08       	sbc	r12, r1
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1b7a:	d1 08       	sbc	r13, r1
    1b7c:	c7 01       	movw	r24, r14
    1b7e:	8c 0d       	add	r24, r12
    1b80:	9d 1d       	adc	r25, r13
    1b82:	b2 01       	movw	r22, r4
    1b84:	a3 01       	movw	r20, r6
    1b86:	0e 94 51 03 	call	0x6a2	; 0x6a2 <pxPortInitialiseStack>
    1b8a:	99 83       	std	Y+1, r25	; 0x01
    1b8c:	88 83       	st	Y, r24
    1b8e:	a1 14       	cp	r10, r1
    1b90:	b1 04       	cpc	r11, r1
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    1b92:	19 f0       	breq	.+6      	; 0x1b9a <xTaskCreate+0xda>
    1b94:	f5 01       	movw	r30, r10
    1b96:	d1 83       	std	Z+1, r29	; 0x01
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1b98:	c0 83       	st	Z, r28
    1b9a:	0f b6       	in	r0, 0x3f	; 63
    1b9c:	f8 94       	cli

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    1b9e:	0f 92       	push	r0
    1ba0:	80 91 4e 20 	lds	r24, 0x204E
	{
		uxCurrentNumberOfTasks++;
    1ba4:	8f 5f       	subi	r24, 0xFF	; 255
    1ba6:	80 93 4e 20 	sts	0x204E, r24
    1baa:	80 91 43 20 	lds	r24, 0x2043
		if( pxCurrentTCB == NULL )
    1bae:	90 91 44 20 	lds	r25, 0x2044
    1bb2:	89 2b       	or	r24, r25
    1bb4:	89 f5       	brne	.+98     	; 0x1c18 <xTaskCreate+0x158>
    1bb6:	d0 93 44 20 	sts	0x2044, r29
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    1bba:	c0 93 43 20 	sts	0x2043, r28
    1bbe:	80 91 4e 20 	lds	r24, 0x204E

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1bc2:	81 30       	cpi	r24, 0x01	; 1
    1bc4:	c9 f5       	brne	.+114    	; 0x1c38 <xTaskCreate+0x178>
    1bc6:	83 e5       	ldi	r24, 0x53	; 83
    1bc8:	90 e2       	ldi	r25, 0x20	; 32
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1bca:	0e 94 ad 05 	call	0xb5a	; 0xb5a <vListInitialise>
    1bce:	8c e5       	ldi	r24, 0x5C	; 92
    1bd0:	90 e2       	ldi	r25, 0x20	; 32
    1bd2:	0e 94 ad 05 	call	0xb5a	; 0xb5a <vListInitialise>
    1bd6:	85 e6       	ldi	r24, 0x65	; 101
    1bd8:	90 e2       	ldi	r25, 0x20	; 32
    1bda:	0e 94 ad 05 	call	0xb5a	; 0xb5a <vListInitialise>
    1bde:	8e e6       	ldi	r24, 0x6E	; 110
    1be0:	90 e2       	ldi	r25, 0x20	; 32
    1be2:	0e 94 ad 05 	call	0xb5a	; 0xb5a <vListInitialise>
    1be6:	67 e7       	ldi	r22, 0x77	; 119
    1be8:	e6 2e       	mov	r14, r22
	}

	vListInitialise( &xDelayedTaskList1 );
    1bea:	60 e2       	ldi	r22, 0x20	; 32
    1bec:	f6 2e       	mov	r15, r22
    1bee:	c7 01       	movw	r24, r14
    1bf0:	0e 94 ad 05 	call	0xb5a	; 0xb5a <vListInitialise>
    1bf4:	00 e8       	ldi	r16, 0x80	; 128
    1bf6:	10 e2       	ldi	r17, 0x20	; 32
	vListInitialise( &xDelayedTaskList2 );
    1bf8:	c8 01       	movw	r24, r16
    1bfa:	0e 94 ad 05 	call	0xb5a	; 0xb5a <vListInitialise>
    1bfe:	8d e8       	ldi	r24, 0x8D	; 141
    1c00:	90 e2       	ldi	r25, 0x20	; 32
	vListInitialise( &xPendingReadyList );
    1c02:	0e 94 ad 05 	call	0xb5a	; 0xb5a <vListInitialise>
    1c06:	f0 92 8a 20 	sts	0x208A, r15
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1c0a:	e0 92 89 20 	sts	0x2089, r14
    1c0e:	10 93 8c 20 	sts	0x208C, r17
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1c12:	00 93 8b 20 	sts	0x208B, r16
    1c16:	10 c0       	rjmp	.+32     	; 0x1c38 <xTaskCreate+0x178>
    1c18:	80 91 4f 20 	lds	r24, 0x204F
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    1c1c:	88 23       	and	r24, r24
    1c1e:	61 f4       	brne	.+24     	; 0x1c38 <xTaskCreate+0x178>
    1c20:	e0 91 43 20 	lds	r30, 0x2043
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    1c24:	f0 91 44 20 	lds	r31, 0x2044
    1c28:	96 89       	ldd	r25, Z+22	; 0x16
    1c2a:	8e 89       	ldd	r24, Y+22	; 0x16
    1c2c:	89 17       	cp	r24, r25
    1c2e:	20 f0       	brcs	.+8      	; 0x1c38 <xTaskCreate+0x178>
    1c30:	d0 93 44 20 	sts	0x2044, r29
				{
					pxCurrentTCB = pxNewTCB;
    1c34:	c0 93 43 20 	sts	0x2043, r28
    1c38:	80 91 52 20 	lds	r24, 0x2052
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    1c3c:	8f 5f       	subi	r24, 0xFF	; 255
    1c3e:	80 93 52 20 	sts	0x2052, r24
    1c42:	9e 89       	ldd	r25, Y+22	; 0x16
    1c44:	80 91 46 20 	lds	r24, 0x2046
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    1c48:	89 17       	cp	r24, r25
    1c4a:	10 f4       	brcc	.+4      	; 0x1c50 <xTaskCreate+0x190>
    1c4c:	90 93 46 20 	sts	0x2046, r25
    1c50:	89 e0       	ldi	r24, 0x09	; 9
    1c52:	98 9f       	mul	r25, r24
    1c54:	c0 01       	movw	r24, r0
    1c56:	11 24       	eor	r1, r1
    1c58:	8d 5a       	subi	r24, 0xAD	; 173
    1c5a:	9f 4d       	sbci	r25, 0xDF	; 223
    1c5c:	b4 01       	movw	r22, r8
    1c5e:	0e 94 c1 05 	call	0xb82	; 0xb82 <vListInsertEnd>
    1c62:	0f 90       	pop	r0
    1c64:	0f be       	out	0x3f, r0	; 63

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    1c66:	80 91 4f 20 	lds	r24, 0x204F

	if( xSchedulerRunning != pdFALSE )
    1c6a:	88 23       	and	r24, r24
    1c6c:	51 f0       	breq	.+20     	; 0x1c82 <xTaskCreate+0x1c2>
    1c6e:	e0 91 43 20 	lds	r30, 0x2043
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    1c72:	f0 91 44 20 	lds	r31, 0x2044
    1c76:	96 89       	ldd	r25, Z+22	; 0x16
    1c78:	8e 89       	ldd	r24, Y+22	; 0x16
    1c7a:	98 17       	cp	r25, r24
    1c7c:	10 f4       	brcc	.+4      	; 0x1c82 <xTaskCreate+0x1c2>
    1c7e:	0e 94 41 04 	call	0x882	; 0x882 <vPortYield>
		{
			taskYIELD_IF_USING_PREEMPTION();
    1c82:	81 e0       	ldi	r24, 0x01	; 1
    1c84:	df 91       	pop	r29
    1c86:	cf 91       	pop	r28
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
    1c88:	1f 91       	pop	r17
    1c8a:	0f 91       	pop	r16
    1c8c:	ff 90       	pop	r15
    1c8e:	ef 90       	pop	r14
    1c90:	df 90       	pop	r13
    1c92:	cf 90       	pop	r12
    1c94:	bf 90       	pop	r11
    1c96:	af 90       	pop	r10
    1c98:	9f 90       	pop	r9
    1c9a:	8f 90       	pop	r8
    1c9c:	7f 90       	pop	r7
    1c9e:	6f 90       	pop	r6
    1ca0:	5f 90       	pop	r5
    1ca2:	4f 90       	pop	r4
    1ca4:	08 95       	ret

00001ca6 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1ca6:	ef 92       	push	r14
    1ca8:	ff 92       	push	r15
    1caa:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    1cac:	83 e8       	ldi	r24, 0x83	; 131
    1cae:	9c e0       	ldi	r25, 0x0C	; 12
    1cb0:	6d e6       	ldi	r22, 0x6D	; 109
    1cb2:	72 e0       	ldi	r23, 0x02	; 2
    1cb4:	45 e5       	ldi	r20, 0x55	; 85
    1cb6:	50 e0       	ldi	r21, 0x00	; 0
    1cb8:	20 e0       	ldi	r18, 0x00	; 0
    1cba:	30 e0       	ldi	r19, 0x00	; 0
    1cbc:	00 e0       	ldi	r16, 0x00	; 0
    1cbe:	e0 e5       	ldi	r30, 0x50	; 80
    1cc0:	ee 2e       	mov	r14, r30
    1cc2:	e0 e2       	ldi	r30, 0x20	; 32
    1cc4:	fe 2e       	mov	r15, r30
    1cc6:	fc de       	rcall	.-520    	; 0x1ac0 <xTaskCreate>
    1cc8:	81 30       	cpi	r24, 0x01	; 1
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1cca:	89 f4       	brne	.+34     	; 0x1cee <vTaskStartScheduler+0x48>
    1ccc:	f8 94       	cli
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    1cce:	8f ef       	ldi	r24, 0xFF	; 255
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1cd0:	9f ef       	ldi	r25, 0xFF	; 255
    1cd2:	90 93 4b 20 	sts	0x204B, r25
    1cd6:	80 93 4a 20 	sts	0x204A, r24
    1cda:	81 e0       	ldi	r24, 0x01	; 1
		xSchedulerRunning = pdTRUE;
    1cdc:	80 93 4f 20 	sts	0x204F, r24
    1ce0:	10 92 49 20 	sts	0x2049, r1
		xTickCount = ( TickType_t ) 0U;
    1ce4:	10 92 48 20 	sts	0x2048, r1
    1ce8:	0e 94 9c 03 	call	0x738	; 0x738 <xPortStartScheduler>
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1cec:	09 c0       	rjmp	.+18     	; 0x1d00 <vTaskStartScheduler+0x5a>
    1cee:	8f 3f       	cpi	r24, 0xFF	; 255
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    1cf0:	39 f4       	brne	.+14     	; 0x1d00 <vTaskStartScheduler+0x5a>
    1cf2:	64 e8       	ldi	r22, 0x84	; 132
    1cf4:	77 e0       	ldi	r23, 0x07	; 7
    1cf6:	80 e0       	ldi	r24, 0x00	; 0
    1cf8:	90 e0       	ldi	r25, 0x00	; 0
    1cfa:	42 e5       	ldi	r20, 0x52	; 82
    1cfc:	52 e0       	ldi	r21, 0x02	; 2
    1cfe:	92 d2       	rcall	.+1316   	; 0x2224 <vAssertCalled>
    1d00:	0f 91       	pop	r16
    1d02:	ff 90       	pop	r15
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    1d04:	ef 90       	pop	r14
    1d06:	08 95       	ret

00001d08 <xArePollingQueuesStillRunning>:

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    1d08:	80 91 96 20 	lds	r24, 0x2096
    1d0c:	88 23       	and	r24, r24
    1d0e:	21 f0       	breq	.+8      	; 0x1d18 <xArePollingQueuesStillRunning+0x10>
    1d10:	80 91 97 20 	lds	r24, 0x2097
    1d14:	81 11       	cpse	r24, r1
    1d16:	81 e0       	ldi	r24, 0x01	; 1
		xReturn = pdTRUE;
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    1d18:	10 92 96 20 	sts	0x2096, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
    1d1c:	10 92 97 20 	sts	0x2097, r1

	return xReturn;
}
    1d20:	08 95       	ret

00001d22 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
    1d22:	ef 92       	push	r14
    1d24:	ff 92       	push	r15
    1d26:	0f 93       	push	r16
    1d28:	1f 93       	push	r17
    1d2a:	18 2f       	mov	r17, r24
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
    1d2c:	8a e0       	ldi	r24, 0x0A	; 10
    1d2e:	62 e0       	ldi	r22, 0x02	; 2
    1d30:	40 e0       	ldi	r20, 0x00	; 0
    1d32:	55 db       	rcall	.-2390   	; 0x13de <xQueueGenericCreate>
    1d34:	90 93 99 20 	sts	0x2099, r25
    1d38:	80 93 98 20 	sts	0x2098, r24
    1d3c:	89 2b       	or	r24, r25

	if( xPolledQueue != NULL )
    1d3e:	a9 f0       	breq	.+42     	; 0x1d6a <vStartPolledQueueTasks+0x48>
    1d40:	85 ef       	ldi	r24, 0xF5	; 245
		by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
		defined to be less than 1. */
		vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

		/* Spawn the producer and consumer. */
		xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    1d42:	9e e0       	ldi	r25, 0x0E	; 14
    1d44:	62 e7       	ldi	r22, 0x72	; 114
    1d46:	72 e0       	ldi	r23, 0x02	; 2
    1d48:	45 e5       	ldi	r20, 0x55	; 85
    1d4a:	50 e0       	ldi	r21, 0x00	; 0
    1d4c:	28 e9       	ldi	r18, 0x98	; 152
    1d4e:	30 e2       	ldi	r19, 0x20	; 32
    1d50:	01 2f       	mov	r16, r17
    1d52:	ee 24       	eor	r14, r14
    1d54:	ff 24       	eor	r15, r15
    1d56:	b4 de       	rcall	.-664    	; 0x1ac0 <xTaskCreate>
    1d58:	8a eb       	ldi	r24, 0xBA	; 186
    1d5a:	9e e0       	ldi	r25, 0x0E	; 14
		xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
    1d5c:	6a e7       	ldi	r22, 0x7A	; 122
    1d5e:	72 e0       	ldi	r23, 0x02	; 2
    1d60:	45 e5       	ldi	r20, 0x55	; 85
    1d62:	50 e0       	ldi	r21, 0x00	; 0
    1d64:	28 e9       	ldi	r18, 0x98	; 152
    1d66:	30 e2       	ldi	r19, 0x20	; 32
    1d68:	ab de       	rcall	.-682    	; 0x1ac0 <xTaskCreate>
    1d6a:	1f 91       	pop	r17
    1d6c:	0f 91       	pop	r16
    1d6e:	ff 90       	pop	r15
	}
}
    1d70:	ef 90       	pop	r14
    1d72:	08 95       	ret

00001d74 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    1d74:	cf 92       	push	r12
    1d76:	df 92       	push	r13
    1d78:	ef 92       	push	r14
    1d7a:	ff 92       	push	r15
    1d7c:	0f 93       	push	r16
    1d7e:	1f 93       	push	r17
    1d80:	df 93       	push	r29
    1d82:	cf 93       	push	r28
    1d84:	0f 92       	push	r0
    1d86:	0f 92       	push	r0
    1d88:	cd b7       	in	r28, 0x3d	; 61
    1d8a:	de b7       	in	r29, 0x3e	; 62
    1d8c:	7c 01       	movw	r14, r24
uint16_t usValue = ( uint16_t ) 0;
    1d8e:	1a 82       	std	Y+2, r1	; 0x02
    1d90:	19 82       	std	Y+1, r1	; 0x01
    1d92:	00 e0       	ldi	r16, 0x00	; 0
    1d94:	10 e0       	ldi	r17, 0x00	; 0
	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    1d96:	6e 01       	movw	r12, r28
    1d98:	08 94       	sec
    1d9a:	c1 1c       	adc	r12, r1
    1d9c:	d1 1c       	adc	r13, r1
    1d9e:	1e c0       	rjmp	.+60     	; 0x1ddc <vPolledQueueProducer+0x68>
    1da0:	f7 01       	movw	r30, r14
    1da2:	80 81       	ld	r24, Z
    1da4:	91 81       	ldd	r25, Z+1	; 0x01
    1da6:	b6 01       	movw	r22, r12
    1da8:	40 e0       	ldi	r20, 0x00	; 0
    1daa:	50 e0       	ldi	r21, 0x00	; 0
    1dac:	20 e0       	ldi	r18, 0x00	; 0
    1dae:	06 da       	rcall	.-3060   	; 0x11bc <xQueueGenericSend>
    1db0:	81 30       	cpi	r24, 0x01	; 1
    1db2:	11 f0       	breq	.+4      	; 0x1db8 <vPolledQueueProducer+0x44>
    1db4:	01 e0       	ldi	r16, 0x01	; 1
    1db6:	11 c0       	rjmp	.+34     	; 0x1dda <vPolledQueueProducer+0x66>
    1db8:	00 23       	and	r16, r16
				has been an error. */
				xError = pdTRUE;
			}
			else
			{
				if( xError == pdFALSE )
    1dba:	51 f4       	brne	.+20     	; 0x1dd0 <vPolledQueueProducer+0x5c>
    1dbc:	0f b6       	in	r0, 0x3f	; 63
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    1dbe:	f8 94       	cli
    1dc0:	0f 92       	push	r0
    1dc2:	80 91 97 20 	lds	r24, 0x2097
						xPollingProducerCount++;
    1dc6:	8f 5f       	subi	r24, 0xFF	; 255
    1dc8:	80 93 97 20 	sts	0x2097, r24
    1dcc:	0f 90       	pop	r0
					portEXIT_CRITICAL();
    1dce:	0f be       	out	0x3f, r0	; 63
    1dd0:	89 81       	ldd	r24, Y+1	; 0x01
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    1dd2:	9a 81       	ldd	r25, Y+2	; 0x02
    1dd4:	01 96       	adiw	r24, 0x01	; 1
    1dd6:	9a 83       	std	Y+2, r25	; 0x02
    1dd8:	89 83       	std	Y+1, r24	; 0x01
    1dda:	1f 5f       	subi	r17, 0xFF	; 255
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    1ddc:	13 30       	cpi	r17, 0x03	; 3
    1dde:	04 f3       	brlt	.-64     	; 0x1da0 <vPolledQueueProducer+0x2c>
    1de0:	88 ec       	ldi	r24, 0xC8	; 200
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    1de2:	90 e0       	ldi	r25, 0x00	; 0
    1de4:	d9 dd       	rcall	.-1102   	; 0x1998 <vTaskDelay>
    1de6:	10 e0       	ldi	r17, 0x00	; 0
    1de8:	db cf       	rjmp	.-74     	; 0x1da0 <vPolledQueueProducer+0x2c>

00001dea <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    1dea:	9f 92       	push	r9
    1dec:	af 92       	push	r10
    1dee:	bf 92       	push	r11
    1df0:	cf 92       	push	r12
    1df2:	df 92       	push	r13
    1df4:	ef 92       	push	r14
    1df6:	ff 92       	push	r15
    1df8:	0f 93       	push	r16
    1dfa:	1f 93       	push	r17
    1dfc:	df 93       	push	r29
    1dfe:	cf 93       	push	r28
    1e00:	0f 92       	push	r0
    1e02:	0f 92       	push	r0
    1e04:	cd b7       	in	r28, 0x3d	; 61
    1e06:	de b7       	in	r29, 0x3e	; 62
    1e08:	98 2e       	mov	r9, r24
    1e0a:	c9 2e       	mov	r12, r25
    1e0c:	ee 24       	eor	r14, r14
    1e0e:	ff 24       	eor	r15, r15
    1e10:	dd 24       	eor	r13, r13
	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    1e12:	5e 01       	movw	r10, r28
    1e14:	08 94       	sec
    1e16:	a1 1c       	adc	r10, r1
    1e18:	b1 1c       	adc	r11, r1
    1e1a:	22 c0       	rjmp	.+68     	; 0x1e60 <vPolledQueueConsumer+0x76>
    1e1c:	f8 01       	movw	r30, r16
    1e1e:	80 81       	ld	r24, Z
    1e20:	91 81       	ldd	r25, Z+1	; 0x01
    1e22:	b5 01       	movw	r22, r10
    1e24:	40 e0       	ldi	r20, 0x00	; 0
    1e26:	50 e0       	ldi	r21, 0x00	; 0
    1e28:	20 e0       	ldi	r18, 0x00	; 0
    1e2a:	01 d9       	rcall	.-3582   	; 0x102e <xQueueGenericReceive>
    1e2c:	81 30       	cpi	r24, 0x01	; 1
    1e2e:	c1 f4       	brne	.+48     	; 0x1e60 <vPolledQueueConsumer+0x76>
    1e30:	29 81       	ldd	r18, Y+1	; 0x01
			{
				if( usData != usExpectedValue )
    1e32:	3a 81       	ldd	r19, Y+2	; 0x02
    1e34:	2e 15       	cp	r18, r14
    1e36:	3f 05       	cpc	r19, r15
    1e38:	19 f0       	breq	.+6      	; 0x1e40 <vPolledQueueConsumer+0x56>
    1e3a:	dd 24       	eor	r13, r13
    1e3c:	d3 94       	inc	r13
    1e3e:	0c c0       	rjmp	.+24     	; 0x1e58 <vPolledQueueConsumer+0x6e>
    1e40:	dd 20       	and	r13, r13
					value should again be correct. */
					usExpectedValue = usData;
				}
				else
				{
					if( xError == pdFALSE )
    1e42:	51 f4       	brne	.+20     	; 0x1e58 <vPolledQueueConsumer+0x6e>
    1e44:	0f b6       	in	r0, 0x3f	; 63
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    1e46:	f8 94       	cli
    1e48:	0f 92       	push	r0
    1e4a:	80 91 96 20 	lds	r24, 0x2096
							xPollingConsumerCount++;
    1e4e:	8f 5f       	subi	r24, 0xFF	; 255
    1e50:	80 93 96 20 	sts	0x2096, r24
    1e54:	0f 90       	pop	r0
						portEXIT_CRITICAL();
    1e56:	0f be       	out	0x3f, r0	; 63
    1e58:	79 01       	movw	r14, r18
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    1e5a:	08 94       	sec
    1e5c:	e1 1c       	adc	r14, r1
    1e5e:	f1 1c       	adc	r15, r1
    1e60:	09 2d       	mov	r16, r9
BaseType_t xError = pdFALSE;

	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
    1e62:	1c 2d       	mov	r17, r12
    1e64:	f8 01       	movw	r30, r16
    1e66:	80 81       	ld	r24, Z
    1e68:	91 81       	ldd	r25, Z+1	; 0x01
    1e6a:	0e 94 1a 07 	call	0xe34	; 0xe34 <uxQueueMessagesWaiting>
    1e6e:	88 23       	and	r24, r24
    1e70:	a9 f6       	brne	.-86     	; 0x1e1c <vPolledQueueConsumer+0x32>
    1e72:	84 eb       	ldi	r24, 0xB4	; 180
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    1e74:	90 e0       	ldi	r25, 0x00	; 0
    1e76:	90 dd       	rcall	.-1248   	; 0x1998 <vTaskDelay>
    1e78:	f3 cf       	rjmp	.-26     	; 0x1e60 <vPolledQueueConsumer+0x76>

00001e7a <xAreComTestTasksStillRunning>:
BaseType_t xReturn;

	/* If the count of successful reception loops has not changed than at
	some time an error occurred (i.e. a character was received out of sequence)
	and we will return false. */
	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
    1e7a:	80 91 9a 20 	lds	r24, 0x209A
		xReturn = pdTRUE;
	}

	/* Reset the count of successful Rx loops.  When this function is called
	again we expect this to have been incremented. */
	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
    1e7e:	10 92 9a 20 	sts	0x209A, r1
    1e82:	81 11       	cpse	r24, r1
    1e84:	81 e0       	ldi	r24, 0x01	; 1

	return xReturn;
}
    1e86:	08 95       	ret

00001e88 <vAltStartComTestTasks>:
static volatile UBaseType_t uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( UBaseType_t uxPriority, uint32_t ulBaudRate, UBaseType_t uxLED )
{
    1e88:	ef 92       	push	r14
    1e8a:	ff 92       	push	r15
    1e8c:	0f 93       	push	r16
    1e8e:	1f 93       	push	r17
    1e90:	18 2f       	mov	r17, r24
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
    1e92:	20 93 9b 20 	sts	0x209B, r18
	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
    1e96:	cb 01       	movw	r24, r22
    1e98:	ba 01       	movw	r22, r20
    1e9a:	48 e1       	ldi	r20, 0x18	; 24
    1e9c:	0e 94 50 01 	call	0x2a0	; 0x2a0 <xSerialPortInitMinimal>

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( TaskHandle_t * ) NULL );
    1ea0:	01 2f       	mov	r16, r17
    1ea2:	01 50       	subi	r16, 0x01	; 1
    1ea4:	8f ea       	ldi	r24, 0xAF	; 175
    1ea6:	9f e0       	ldi	r25, 0x0F	; 15
    1ea8:	62 e8       	ldi	r22, 0x82	; 130
    1eaa:	72 e0       	ldi	r23, 0x02	; 2
    1eac:	45 e5       	ldi	r20, 0x55	; 85
    1eae:	50 e0       	ldi	r21, 0x00	; 0
    1eb0:	20 e0       	ldi	r18, 0x00	; 0
    1eb2:	30 e0       	ldi	r19, 0x00	; 0
    1eb4:	ee 24       	eor	r14, r14
    1eb6:	ff 24       	eor	r15, r15
    1eb8:	03 de       	rcall	.-1018   	; 0x1ac0 <xTaskCreate>
    1eba:	8c e6       	ldi	r24, 0x6C	; 108
	xTaskCreate( vComRxTask, "COMRx", comSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
    1ebc:	9f e0       	ldi	r25, 0x0F	; 15
    1ebe:	68 e8       	ldi	r22, 0x88	; 136
    1ec0:	72 e0       	ldi	r23, 0x02	; 2
    1ec2:	45 e5       	ldi	r20, 0x55	; 85
    1ec4:	50 e0       	ldi	r21, 0x00	; 0
    1ec6:	20 e0       	ldi	r18, 0x00	; 0
    1ec8:	30 e0       	ldi	r19, 0x00	; 0
    1eca:	01 2f       	mov	r16, r17
    1ecc:	f9 dd       	rcall	.-1038   	; 0x1ac0 <xTaskCreate>
    1ece:	1f 91       	pop	r17
    1ed0:	0f 91       	pop	r16
}
    1ed2:	ff 90       	pop	r15
    1ed4:	ef 90       	pop	r14
    1ed6:	08 95       	ret

00001ed8 <vComRxTask>:
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
    1ed8:	ef 92       	push	r14
    1eda:	ff 92       	push	r15
    1edc:	0f 93       	push	r16
    1ede:	1f 93       	push	r17
    1ee0:	df 93       	push	r29
    1ee2:	cf 93       	push	r28
    1ee4:	0f 92       	push	r0
    1ee6:	cd b7       	in	r28, 0x3d	; 61
    1ee8:	de b7       	in	r29, 0x3e	; 62
    1eea:	00 e0       	ldi	r16, 0x00	; 0
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
    1eec:	7e 01       	movw	r14, r28
    1eee:	08 94       	sec
    1ef0:	e1 1c       	adc	r14, r1
    1ef2:	f1 1c       	adc	r15, r1
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
    1ef4:	11 e4       	ldi	r17, 0x41	; 65
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
    1ef6:	80 e0       	ldi	r24, 0x00	; 0
    1ef8:	90 e0       	ldi	r25, 0x00	; 0
    1efa:	b7 01       	movw	r22, r14
    1efc:	4f ef       	ldi	r20, 0xFF	; 255
    1efe:	5f ef       	ldi	r21, 0xFF	; 255
    1f00:	0e 94 47 01 	call	0x28e	; 0x28e <xSerialGetChar>
    1f04:	88 23       	and	r24, r24
    1f06:	51 f0       	breq	.+20     	; 0x1f1c <vComRxTask+0x44>
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
    1f08:	89 81       	ldd	r24, Y+1	; 0x01
    1f0a:	81 17       	cp	r24, r17
    1f0c:	11 f0       	breq	.+4      	; 0x1f12 <vComRxTask+0x3a>
    1f0e:	11 e0       	ldi	r17, 0x01	; 1
    1f10:	09 c0       	rjmp	.+18     	; 0x1f24 <vComRxTask+0x4c>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
    1f12:	80 91 9b 20 	lds	r24, 0x209B
    1f16:	8f 5f       	subi	r24, 0xFF	; 255
    1f18:	0e 94 0e 03 	call	0x61c	; 0x61c <vParTestToggleLED>

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
    1f1c:	1f 5f       	subi	r17, 0xFF	; 255
    1f1e:	19 35       	cpi	r17, 0x59	; 89
    1f20:	51 f7       	brne	.-44     	; 0x1ef6 <vComRxTask+0x1e>
    1f22:	10 e0       	ldi	r17, 0x00	; 0
				}
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
    1f24:	80 91 9b 20 	lds	r24, 0x209B
    1f28:	8f 5f       	subi	r24, 0xFF	; 255
    1f2a:	60 e0       	ldi	r22, 0x00	; 0
    1f2c:	0e 94 25 03 	call	0x64a	; 0x64a <vParTestSetLED>

		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
    1f30:	11 30       	cpi	r17, 0x01	; 1
    1f32:	69 f4       	brne	.+26     	; 0x1f4e <vComRxTask+0x76>
    1f34:	07 c0       	rjmp	.+14     	; 0x1f44 <vComRxTask+0x6c>
		{
			while( cByteRxed != comLAST_BYTE )
			{
				/* Block until the next char is available. */
				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
    1f36:	80 e0       	ldi	r24, 0x00	; 0
    1f38:	90 e0       	ldi	r25, 0x00	; 0
    1f3a:	b7 01       	movw	r22, r14
    1f3c:	4f ef       	ldi	r20, 0xFF	; 255
    1f3e:	5f ef       	ldi	r21, 0xFF	; 255
    1f40:	0e 94 47 01 	call	0x28e	; 0x28e <xSerialGetChar>
		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
		{
			while( cByteRxed != comLAST_BYTE )
    1f44:	89 81       	ldd	r24, Y+1	; 0x01
    1f46:	88 35       	cpi	r24, 0x58	; 88
    1f48:	b1 f7       	brne	.-20     	; 0x1f36 <vComRxTask+0x5e>

			/* Note that an error occurred which caused us to have to resync.
			We use this to stop incrementing the loop counter so
			sAreComTestTasksStillRunning() will return false - indicating an
			error. */
			xErrorOccurred++;
    1f4a:	0f 5f       	subi	r16, 0xFF	; 255
    1f4c:	d3 cf       	rjmp	.-90     	; 0x1ef4 <vComRxTask+0x1c>
			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
		}
		else
		{
			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
    1f4e:	02 30       	cpi	r16, 0x02	; 2
    1f50:	8c f6       	brge	.-94     	; 0x1ef4 <vComRxTask+0x1c>
				occurring (i.e. an unexpected character being received) will
				prevent this counter being incremented for the rest of the
				execution.   Don't worry about mutual exclusion on this
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
    1f52:	80 91 9a 20 	lds	r24, 0x209A
    1f56:	8f 5f       	subi	r24, 0xFF	; 255
    1f58:	80 93 9a 20 	sts	0x209A, r24
    1f5c:	cb cf       	rjmp	.-106    	; 0x1ef4 <vComRxTask+0x1c>

00001f5e <vComTxTask>:
	xTaskCreate( vComRxTask, "COMRx", comSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComTxTask, pvParameters )
{
    1f5e:	1f 93       	push	r17
    1f60:	11 e4       	ldi	r17, 0x41	; 65
    1f62:	0e c0       	rjmp	.+28     	; 0x1f80 <vComTxTask+0x22>
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
    1f64:	80 e0       	ldi	r24, 0x00	; 0
    1f66:	90 e0       	ldi	r25, 0x00	; 0
    1f68:	61 2f       	mov	r22, r17
    1f6a:	40 e0       	ldi	r20, 0x00	; 0
    1f6c:	50 e0       	ldi	r21, 0x00	; 0
    1f6e:	0e 94 2a 01 	call	0x254	; 0x254 <xSerialPutChar>
    1f72:	81 30       	cpi	r24, 0x01	; 1
    1f74:	21 f4       	brne	.+8      	; 0x1f7e <vComTxTask+0x20>
			{
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
    1f76:	80 91 9b 20 	lds	r24, 0x209B
    1f7a:	0e 94 0e 03 	call	0x61c	; 0x61c <vParTestToggleLED>

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
    1f7e:	1f 5f       	subi	r17, 0xFF	; 255
    1f80:	19 35       	cpi	r17, 0x59	; 89
    1f82:	84 f3       	brlt	.-32     	; 0x1f64 <vComTxTask+0x6>
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
    1f84:	80 91 9b 20 	lds	r24, 0x209B
    1f88:	60 e0       	ldi	r22, 0x00	; 0
    1f8a:	0e 94 25 03 	call	0x64a	; 0x64a <vParTestSetLED>

		/* We have posted all the characters in the string - wait before
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
    1f8e:	5c da       	rcall	.-2888   	; 0x1448 <xTaskGetTickCount>
    1f90:	03 96       	adiw	r24, 0x03	; 3

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
    1f92:	66 e9       	ldi	r22, 0x96	; 150
    1f94:	70 e0       	ldi	r23, 0x00	; 0
    1f96:	3e d2       	rcall	.+1148   	; 0x2414 <__udivmodhi4>
    1f98:	82 33       	cpi	r24, 0x32	; 50
    1f9a:	91 05       	cpc	r25, r1

		/* ...but we do want to wait. */
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
    1f9c:	10 f4       	brcc	.+4      	; 0x1fa2 <vComTxTask+0x44>
    1f9e:	82 e3       	ldi	r24, 0x32	; 50
    1fa0:	90 e0       	ldi	r25, 0x00	; 0
    1fa2:	fa dc       	rcall	.-1548   	; 0x1998 <vTaskDelay>
    1fa4:	11 e4       	ldi	r17, 0x41	; 65
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
		}

		vTaskDelay( xTimeToWait );
    1fa6:	de cf       	rjmp	.-68     	; 0x1f64 <vComTxTask+0x6>

00001fa8 <vStartFlashCoRoutines>:

/*
 * See the header file for details.
 */
void vStartFlashCoRoutines( UBaseType_t uxNumberToCreate )
{
    1fa8:	0f 93       	push	r16
    1faa:	1f 93       	push	r17
    1fac:	08 2f       	mov	r16, r24
    1fae:	89 30       	cpi	r24, 0x09	; 9
    1fb0:	08 f0       	brcs	.+2      	; 0x1fb4 <vStartFlashCoRoutines+0xc>
    1fb2:	08 e0       	ldi	r16, 0x08	; 8
	{
		uxNumberToCreate = crfMAX_FLASH_TASKS;
	}

	/* Create the queue used to pass data between the co-routines. */
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );
    1fb4:	81 e0       	ldi	r24, 0x01	; 1
    1fb6:	61 e0       	ldi	r22, 0x01	; 1
    1fb8:	40 e0       	ldi	r20, 0x00	; 0
    1fba:	11 da       	rcall	.-3038   	; 0x13de <xQueueGenericCreate>
    1fbc:	90 93 9d 20 	sts	0x209D, r25
    1fc0:	80 93 9c 20 	sts	0x209C, r24
    1fc4:	89 2b       	or	r24, r25

	if( xFlashQueue )
    1fc6:	89 f0       	breq	.+34     	; 0x1fea <vStartFlashCoRoutines+0x42>
    1fc8:	10 e0       	ldi	r17, 0x00	; 0
    1fca:	07 c0       	rjmp	.+14     	; 0x1fda <vStartFlashCoRoutines+0x32>
    1fcc:	8f e3       	ldi	r24, 0x3F	; 63
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
    1fce:	90 e1       	ldi	r25, 0x10	; 16
    1fd0:	60 e0       	ldi	r22, 0x00	; 0
    1fd2:	41 2f       	mov	r20, r17
    1fd4:	0e 94 3c 05 	call	0xa78	; 0xa78 <xCoRoutineCreate>
    1fd8:	1f 5f       	subi	r17, 0xFF	; 255
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( UBaseType_t ) );

	if( xFlashQueue )
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    1fda:	10 17       	cp	r17, r16
    1fdc:	b8 f3       	brcs	.-18     	; 0x1fcc <vStartFlashCoRoutines+0x24>
    1fde:	88 ef       	ldi	r24, 0xF8	; 248
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    1fe0:	9f e0       	ldi	r25, 0x0F	; 15
    1fe2:	61 e0       	ldi	r22, 0x01	; 1
    1fe4:	40 e0       	ldi	r20, 0x00	; 0
    1fe6:	0e 94 3c 05 	call	0xa78	; 0xa78 <xCoRoutineCreate>
    1fea:	1f 91       	pop	r17
	}
}
    1fec:	0f 91       	pop	r16
    1fee:	08 95       	ret

00001ff0 <prvFlashCoRoutine>:
	crEND();
}
/*-----------------------------------------------------------*/

static void prvFlashCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    1ff0:	0f 93       	push	r16
    1ff2:	1f 93       	push	r17
    1ff4:	df 93       	push	r29
    1ff6:	cf 93       	push	r28
    1ff8:	0f 92       	push	r0
    1ffa:	cd b7       	in	r28, 0x3d	; 61
    1ffc:	de b7       	in	r29, 0x3e	; 62
static as we do not need it to maintain their state between blocks. */
BaseType_t xResult;
UBaseType_t uxLEDToFlash;

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    1ffe:	8c 01       	movw	r16, r24
    2000:	fc 01       	movw	r30, r24
    2002:	80 8d       	ldd	r24, Z+24	; 0x18
    2004:	91 8d       	ldd	r25, Z+25	; 0x19
    2006:	f1 e0       	ldi	r31, 0x01	; 1
    2008:	82 3c       	cpi	r24, 0xC2	; 194
    200a:	9f 07       	cpc	r25, r31
    200c:	b1 f0       	breq	.+44     	; 0x203a <prvFlashCoRoutine+0x4a>
    200e:	21 e0       	ldi	r18, 0x01	; 1
    2010:	83 3c       	cpi	r24, 0xC3	; 195
    2012:	92 07       	cpc	r25, r18
    2014:	51 f1       	breq	.+84     	; 0x206a <prvFlashCoRoutine+0x7a>
    2016:	89 2b       	or	r24, r25
    2018:	61 f5       	brne	.+88     	; 0x2072 <prvFlashCoRoutine+0x82>
	( void ) uxIndex;
	
	for( ;; )
	{
		/* Block to wait for the number of the LED to flash. */
		crQUEUE_RECEIVE( xHandle, xFlashQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );		
    201a:	80 91 9c 20 	lds	r24, 0x209C
    201e:	90 91 9d 20 	lds	r25, 0x209D
    2022:	be 01       	movw	r22, r28
    2024:	6f 5f       	subi	r22, 0xFF	; 255
    2026:	7f 4f       	sbci	r23, 0xFF	; 255
    2028:	4f ef       	ldi	r20, 0xFF	; 255
    202a:	5f ef       	ldi	r21, 0xFF	; 255
    202c:	0e 94 a4 06 	call	0xd48	; 0xd48 <xQueueCRReceive>
    2030:	8c 3f       	cpi	r24, 0xFC	; 252
    2032:	71 f4       	brne	.+28     	; 0x2050 <prvFlashCoRoutine+0x60>
    2034:	82 ec       	ldi	r24, 0xC2	; 194
    2036:	91 e0       	ldi	r25, 0x01	; 1
    2038:	0f c0       	rjmp	.+30     	; 0x2058 <prvFlashCoRoutine+0x68>
    203a:	80 91 9c 20 	lds	r24, 0x209C
    203e:	90 91 9d 20 	lds	r25, 0x209D
    2042:	be 01       	movw	r22, r28
    2044:	6f 5f       	subi	r22, 0xFF	; 255
    2046:	7f 4f       	sbci	r23, 0xFF	; 255
    2048:	40 e0       	ldi	r20, 0x00	; 0
    204a:	50 e0       	ldi	r21, 0x00	; 0
    204c:	0e 94 a4 06 	call	0xd48	; 0xd48 <xQueueCRReceive>
    2050:	8b 3f       	cpi	r24, 0xFB	; 251
    2052:	31 f4       	brne	.+12     	; 0x2060 <prvFlashCoRoutine+0x70>
    2054:	83 ec       	ldi	r24, 0xC3	; 195
    2056:	91 e0       	ldi	r25, 0x01	; 1
    2058:	f8 01       	movw	r30, r16
    205a:	91 8f       	std	Z+25, r25	; 0x19
    205c:	80 8f       	std	Z+24, r24	; 0x18
    205e:	09 c0       	rjmp	.+18     	; 0x2072 <prvFlashCoRoutine+0x82>

		if( xResult != pdPASS )
    2060:	81 30       	cpi	r24, 0x01	; 1
    2062:	19 f0       	breq	.+6      	; 0x206a <prvFlashCoRoutine+0x7a>
		{
			/* We would not expect to wake unless we received something. */
			xCoRoutineFlashStatus = pdFAIL;
    2064:	10 92 a3 02 	sts	0x02A3, r1
    2068:	d8 cf       	rjmp	.-80     	; 0x201a <prvFlashCoRoutine+0x2a>
		}
		else
		{
			/* We received the number of an LED to flash - flash it! */
			vParTestToggleLED( uxLEDToFlash );
    206a:	89 81       	ldd	r24, Y+1	; 0x01
    206c:	0e 94 0e 03 	call	0x61c	; 0x61c <vParTestToggleLED>
    2070:	d4 cf       	rjmp	.-88     	; 0x201a <prvFlashCoRoutine+0x2a>
		}
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    2072:	0f 90       	pop	r0
    2074:	cf 91       	pop	r28
    2076:	df 91       	pop	r29
    2078:	1f 91       	pop	r17
    207a:	0f 91       	pop	r16
    207c:	08 95       	ret

0000207e <prvFixedDelayCoRoutine>:
	}
}
/*-----------------------------------------------------------*/

static void prvFixedDelayCoRoutine( CoRoutineHandle_t xHandle, UBaseType_t uxIndex )
{
    207e:	0f 93       	push	r16
    2080:	1f 93       	push	r17
    2082:	df 93       	push	r29
    2084:	cf 93       	push	r28
    2086:	0f 92       	push	r0
    2088:	cd b7       	in	r28, 0x3d	; 61
    208a:	de b7       	in	r29, 0x3e	; 62
    208c:	69 83       	std	Y+1, r22	; 0x01
																400 / portTICK_PERIOD_MS,
																450 / portTICK_PERIOD_MS,
																500  / portTICK_PERIOD_MS };

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    208e:	8c 01       	movw	r16, r24
    2090:	fc 01       	movw	r30, r24
    2092:	80 8d       	ldd	r24, Z+24	; 0x18
    2094:	91 8d       	ldd	r25, Z+25	; 0x19
    2096:	f1 e0       	ldi	r31, 0x01	; 1
    2098:	82 38       	cpi	r24, 0x82	; 130
    209a:	9f 07       	cpc	r25, r31
    209c:	f1 f0       	breq	.+60     	; 0x20da <prvFixedDelayCoRoutine+0x5c>
    209e:	21 e0       	ldi	r18, 0x01	; 1
    20a0:	83 38       	cpi	r24, 0x83	; 131
    20a2:	92 07       	cpc	r25, r18
    20a4:	18 f4       	brcc	.+6      	; 0x20ac <prvFixedDelayCoRoutine+0x2e>
    20a6:	89 2b       	or	r24, r25
    20a8:	41 f0       	breq	.+16     	; 0x20ba <prvFixedDelayCoRoutine+0x3c>
    20aa:	3e c0       	rjmp	.+124    	; 0x2128 <prvFixedDelayCoRoutine+0xaa>
    20ac:	e1 e0       	ldi	r30, 0x01	; 1
    20ae:	83 38       	cpi	r24, 0x83	; 131
    20b0:	9e 07       	cpc	r25, r30
    20b2:	39 f1       	breq	.+78     	; 0x2102 <prvFixedDelayCoRoutine+0x84>
    20b4:	86 59       	subi	r24, 0x96	; 150
    20b6:	91 40       	sbci	r25, 0x01	; 1
    20b8:	b9 f5       	brne	.+110    	; 0x2128 <prvFixedDelayCoRoutine+0xaa>

	for( ;; )
	{
		/* Post our uxIndex value onto the queue.  This is used as the LED to
		flash. */
		crQUEUE_SEND( xHandle, xFlashQueue, ( void * ) &uxIndex, crfPOSTING_BLOCK_TIME, &xResult );
    20ba:	80 91 9c 20 	lds	r24, 0x209C
    20be:	90 91 9d 20 	lds	r25, 0x209D
    20c2:	be 01       	movw	r22, r28
    20c4:	6f 5f       	subi	r22, 0xFF	; 255
    20c6:	7f 4f       	sbci	r23, 0xFF	; 255
    20c8:	40 e0       	ldi	r20, 0x00	; 0
    20ca:	50 e0       	ldi	r21, 0x00	; 0
    20cc:	0e 94 e7 06 	call	0xdce	; 0xdce <xQueueCRSend>
    20d0:	8c 3f       	cpi	r24, 0xFC	; 252
    20d2:	71 f4       	brne	.+28     	; 0x20f0 <prvFixedDelayCoRoutine+0x72>
    20d4:	82 e8       	ldi	r24, 0x82	; 130
    20d6:	91 e0       	ldi	r25, 0x01	; 1
    20d8:	24 c0       	rjmp	.+72     	; 0x2122 <prvFixedDelayCoRoutine+0xa4>
    20da:	80 91 9c 20 	lds	r24, 0x209C
    20de:	90 91 9d 20 	lds	r25, 0x209D
    20e2:	be 01       	movw	r22, r28
    20e4:	6f 5f       	subi	r22, 0xFF	; 255
    20e6:	7f 4f       	sbci	r23, 0xFF	; 255
    20e8:	40 e0       	ldi	r20, 0x00	; 0
    20ea:	50 e0       	ldi	r21, 0x00	; 0
    20ec:	0e 94 e7 06 	call	0xdce	; 0xdce <xQueueCRSend>
    20f0:	8b 3f       	cpi	r24, 0xFB	; 251
    20f2:	19 f4       	brne	.+6      	; 0x20fa <prvFixedDelayCoRoutine+0x7c>
    20f4:	83 e8       	ldi	r24, 0x83	; 131
    20f6:	91 e0       	ldi	r25, 0x01	; 1
    20f8:	14 c0       	rjmp	.+40     	; 0x2122 <prvFixedDelayCoRoutine+0xa4>

		if( xResult != pdPASS )
    20fa:	81 30       	cpi	r24, 0x01	; 1
    20fc:	11 f0       	breq	.+4      	; 0x2102 <prvFixedDelayCoRoutine+0x84>
		{
			/* For the reasons stated at the top of the file we should always
			find that we can post to the queue.  If we could not then an error
			has occurred. */
			xCoRoutineFlashStatus = pdFAIL;
    20fe:	10 92 a3 02 	sts	0x02A3, r1
		}

		crDELAY( xHandle, xFlashRates[ uxIndex ] );
    2102:	e9 81       	ldd	r30, Y+1	; 0x01
    2104:	f0 e0       	ldi	r31, 0x00	; 0
    2106:	ee 0f       	add	r30, r30
    2108:	ff 1f       	adc	r31, r31
    210a:	e8 55       	subi	r30, 0x58	; 88
    210c:	fd 4f       	sbci	r31, 0xFD	; 253
    210e:	80 81       	ld	r24, Z
    2110:	91 81       	ldd	r25, Z+1	; 0x01
    2112:	00 97       	sbiw	r24, 0x00	; 0
    2114:	21 f0       	breq	.+8      	; 0x211e <prvFixedDelayCoRoutine+0xa0>
    2116:	60 e0       	ldi	r22, 0x00	; 0
    2118:	70 e0       	ldi	r23, 0x00	; 0
    211a:	0e 94 02 05 	call	0xa04	; 0xa04 <vCoRoutineAddToDelayedList>
    211e:	86 e9       	ldi	r24, 0x96	; 150
    2120:	91 e0       	ldi	r25, 0x01	; 1
    2122:	f8 01       	movw	r30, r16
    2124:	91 8f       	std	Z+25, r25	; 0x19
    2126:	80 8f       	std	Z+24, r24	; 0x18
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    2128:	0f 90       	pop	r0
    212a:	cf 91       	pop	r28
    212c:	df 91       	pop	r29
    212e:	1f 91       	pop	r17
    2130:	0f 91       	pop	r16
    2132:	08 95       	ret

00002134 <vCompeteingIntMathTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    2134:	9f 92       	push	r9
    2136:	af 92       	push	r10
    2138:	bf 92       	push	r11
    213a:	cf 92       	push	r12
    213c:	df 92       	push	r13
    213e:	ef 92       	push	r14
    2140:	ff 92       	push	r15
    2142:	0f 93       	push	r16
    2144:	1f 93       	push	r17
    2146:	df 93       	push	r29
    2148:	cf 93       	push	r28
    214a:	00 d0       	rcall	.+0      	; 0x214c <vCompeteingIntMathTask+0x18>
    214c:	0f 92       	push	r0
    214e:	cd b7       	in	r28, 0x3d	; 61
    2150:	de b7       	in	r29, 0x3e	; 62
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    2152:	8c 01       	movw	r16, r24
    2154:	ee 24       	eor	r14, r14
    2156:	ff 24       	eor	r15, r15
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    2158:	9b e7       	ldi	r25, 0x7B	; 123
    215a:	a9 2e       	mov	r10, r25
    215c:	b1 2c       	mov	r11, r1
    215e:	c1 2c       	mov	r12, r1
    2160:	d1 2c       	mov	r13, r1
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
				*pxTaskHasExecuted = pdTRUE;
    2162:	99 24       	eor	r9, r9
    2164:	93 94       	inc	r9
    2166:	03 c0       	rjmp	.+6      	; 0x216e <vCompeteingIntMathTask+0x3a>
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
    2168:	81 e0       	ldi	r24, 0x01	; 1
    216a:	e8 2e       	mov	r14, r24
    216c:	f1 2c       	mov	r15, r1
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    216e:	a9 82       	std	Y+1, r10	; 0x01
    2170:	ba 82       	std	Y+2, r11	; 0x02
    2172:	cb 82       	std	Y+3, r12	; 0x03
    2174:	dc 82       	std	Y+4, r13	; 0x04
		lValue += intgCONST2;
    2176:	89 81       	ldd	r24, Y+1	; 0x01
    2178:	9a 81       	ldd	r25, Y+2	; 0x02
    217a:	ab 81       	ldd	r26, Y+3	; 0x03
    217c:	bc 81       	ldd	r27, Y+4	; 0x04
    217e:	89 5b       	subi	r24, 0xB9	; 185
    2180:	9b 46       	sbci	r25, 0x6B	; 107
    2182:	ac 4f       	sbci	r26, 0xFC	; 252
    2184:	bf 4f       	sbci	r27, 0xFF	; 255
    2186:	89 83       	std	Y+1, r24	; 0x01
    2188:	9a 83       	std	Y+2, r25	; 0x02
    218a:	ab 83       	std	Y+3, r26	; 0x03
    218c:	bc 83       	std	Y+4, r27	; 0x04
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    218e:	69 81       	ldd	r22, Y+1	; 0x01
    2190:	7a 81       	ldd	r23, Y+2	; 0x02
    2192:	8b 81       	ldd	r24, Y+3	; 0x03
    2194:	9c 81       	ldd	r25, Y+4	; 0x04
    2196:	2d ef       	ldi	r18, 0xFD	; 253
    2198:	3f ef       	ldi	r19, 0xFF	; 255
    219a:	4f ef       	ldi	r20, 0xFF	; 255
    219c:	5f ef       	ldi	r21, 0xFF	; 255
    219e:	1b d1       	rcall	.+566    	; 0x23d6 <__mulsi3>
    21a0:	69 83       	std	Y+1, r22	; 0x01
    21a2:	7a 83       	std	Y+2, r23	; 0x02
    21a4:	8b 83       	std	Y+3, r24	; 0x03
    21a6:	9c 83       	std	Y+4, r25	; 0x04
    21a8:	69 81       	ldd	r22, Y+1	; 0x01
		lValue /= intgCONST4;
    21aa:	7a 81       	ldd	r23, Y+2	; 0x02
    21ac:	8b 81       	ldd	r24, Y+3	; 0x03
    21ae:	9c 81       	ldd	r25, Y+4	; 0x04
    21b0:	27 e0       	ldi	r18, 0x07	; 7
    21b2:	30 e0       	ldi	r19, 0x00	; 0
    21b4:	40 e0       	ldi	r20, 0x00	; 0
    21b6:	50 e0       	ldi	r21, 0x00	; 0
    21b8:	63 d1       	rcall	.+710    	; 0x2480 <__divmodsi4>
    21ba:	c9 01       	movw	r24, r18
    21bc:	da 01       	movw	r26, r20
    21be:	89 83       	std	Y+1, r24	; 0x01
    21c0:	9a 83       	std	Y+2, r25	; 0x02
    21c2:	ab 83       	std	Y+3, r26	; 0x03
    21c4:	bc 83       	std	Y+4, r27	; 0x04
    21c6:	89 81       	ldd	r24, Y+1	; 0x01
    21c8:	9a 81       	ldd	r25, Y+2	; 0x02

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    21ca:	ab 81       	ldd	r26, Y+3	; 0x03
    21cc:	bc 81       	ldd	r27, Y+4	; 0x04
    21ce:	8b 51       	subi	r24, 0x1B	; 27
    21d0:	97 47       	sbci	r25, 0x77	; 119
    21d2:	ae 4f       	sbci	r26, 0xFE	; 254
    21d4:	bf 4f       	sbci	r27, 0xFF	; 255
    21d6:	41 f6       	brne	.-112    	; 0x2168 <vCompeteingIntMathTask+0x34>
    21d8:	e1 14       	cp	r14, r1
    21da:	f1 04       	cpc	r15, r1
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
    21dc:	09 f0       	breq	.+2      	; 0x21e0 <vCompeteingIntMathTask+0xac>
    21de:	c4 cf       	rjmp	.-120    	; 0x2168 <vCompeteingIntMathTask+0x34>
    21e0:	0f b6       	in	r0, 0x3f	; 63
    21e2:	f8 94       	cli
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    21e4:	0f 92       	push	r0
    21e6:	f8 01       	movw	r30, r16
    21e8:	90 82       	st	Z, r9
				*pxTaskHasExecuted = pdTRUE;
    21ea:	0f 90       	pop	r0
    21ec:	0f be       	out	0x3f, r0	; 63
			portEXIT_CRITICAL();
    21ee:	bf cf       	rjmp	.-130    	; 0x216e <vCompeteingIntMathTask+0x3a>

000021f0 <xAreIntegerMathsTaskStillRunning>:

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    21f0:	80 91 9e 20 	lds	r24, 0x209E
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    21f4:	10 92 9e 20 	sts	0x209E, r1
    21f8:	81 11       	cpse	r24, r1
    21fa:	81 e0       	ldi	r24, 0x01	; 1
	}

	return xReturn;
}
    21fc:	08 95       	ret

000021fe <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
    21fe:	ef 92       	push	r14
    2200:	ff 92       	push	r15
    2202:	0f 93       	push	r16
    2204:	08 2f       	mov	r16, r24
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
    2206:	8a e9       	ldi	r24, 0x9A	; 154
    2208:	90 e1       	ldi	r25, 0x10	; 16
    220a:	6e e8       	ldi	r22, 0x8E	; 142
    220c:	72 e0       	ldi	r23, 0x02	; 2
    220e:	45 e5       	ldi	r20, 0x55	; 85
    2210:	50 e0       	ldi	r21, 0x00	; 0
    2212:	2e e9       	ldi	r18, 0x9E	; 158
    2214:	30 e2       	ldi	r19, 0x20	; 32
    2216:	ee 24       	eor	r14, r14
    2218:	ff 24       	eor	r15, r15
    221a:	52 dc       	rcall	.-1884   	; 0x1ac0 <xTaskCreate>
    221c:	0f 91       	pop	r16
	}
}
    221e:	ff 90       	pop	r15
    2220:	ef 90       	pop	r14
    2222:	08 95       	ret

00002224 <vAssertCalled>:
{
	/* Parameters are not used. */
	( void ) ulLine;
	( void ) pcFileName;

	vParTestSetLED(mainASSERTCALLED_LED, pdTRUE);
    2224:	87 e0       	ldi	r24, 0x07	; 7
    2226:	61 e0       	ldi	r22, 0x01	; 1
    2228:	0c 94 25 03 	jmp	0x64a	; 0x64a <vParTestSetLED>

0000222c <main>:
static QueueHandle_t xQueue = NULL;

/*-----------------------------------------------------------*/

int main( void )
{
    222c:	ef 92       	push	r14
    222e:	ff 92       	push	r15
    2230:	0f 93       	push	r16
	/* Create the queue. */
	xQueue = xQueueCreate( mainDEMOBLINKY_QUEUE_LENGTH, sizeof( unsigned char ) );
    2232:	81 e0       	ldi	r24, 0x01	; 1
    2234:	61 e0       	ldi	r22, 0x01	; 1
    2236:	40 e0       	ldi	r20, 0x00	; 0
    2238:	d2 d8       	rcall	.-3676   	; 0x13de <xQueueGenericCreate>
    223a:	90 93 a0 20 	sts	0x20A0, r25
    223e:	80 93 9f 20 	sts	0x209F, r24
    2242:	0e 94 03 03 	call	0x606	; 0x606 <vParTestInitialise>

	/* Setup the LED's for output. */
	vParTestInitialise();
    2246:	80 91 9f 20 	lds	r24, 0x209F

	/* Demo Blinky tasks */
	if( xQueue != NULL )
    224a:	90 91 a0 20 	lds	r25, 0x20A0
    224e:	89 2b       	or	r24, r25
    2250:	b1 f0       	breq	.+44     	; 0x227e <main+0x52>
    2252:	89 ec       	ldi	r24, 0xC9	; 201
	{
		/* Start the two tasks as described in the comments at the top of this file. */
		xTaskCreate( prvQueueReceiveTask,					/* The function that implements the task. */
    2254:	91 e1       	ldi	r25, 0x11	; 17
    2256:	66 e9       	ldi	r22, 0x96	; 150
    2258:	72 e0       	ldi	r23, 0x02	; 2
    225a:	45 e5       	ldi	r20, 0x55	; 85
    225c:	50 e0       	ldi	r21, 0x00	; 0
    225e:	22 e2       	ldi	r18, 0x22	; 34
    2260:	30 e0       	ldi	r19, 0x00	; 0
    2262:	02 e0       	ldi	r16, 0x02	; 2
    2264:	ee 24       	eor	r14, r14
    2266:	ff 24       	eor	r15, r15
    2268:	2b dc       	rcall	.-1962   	; 0x1ac0 <xTaskCreate>
    226a:	8d e9       	ldi	r24, 0x9D	; 157
    226c:	91 e1       	ldi	r25, 0x11	; 17
					configMINIMAL_STACK_SIZE, 				/* The size of the stack to allocate to the task. */
					( void * ) mainDEMOBLINKY_RECEIVE_PARAMETER, /* The parameter passed to the task - just to check the functionality. */
					mainDEMOBLINKY_RECEIVE_PRIORITY, 		/* The priority assigned to the task. */
					NULL );									/* The task handle is not required, so NULL is passed. */

		xTaskCreate( prvQueueSendTask, "TX", configMINIMAL_STACK_SIZE, ( void * ) mainDEMOBLINKY_SEND_PARAMETER, mainDEMOBLINKY_SEND_PRIORITY, NULL );
    226e:	69 e9       	ldi	r22, 0x99	; 153
    2270:	72 e0       	ldi	r23, 0x02	; 2
    2272:	45 e5       	ldi	r20, 0x55	; 85
    2274:	50 e0       	ldi	r21, 0x00	; 0
    2276:	21 e1       	ldi	r18, 0x11	; 17
    2278:	31 e1       	ldi	r19, 0x11	; 17
    227a:	01 e0       	ldi	r16, 0x01	; 1
    227c:	21 dc       	rcall	.-1982   	; 0x1ac0 <xTaskCreate>
    227e:	80 e0       	ldi	r24, 0x00	; 0
    2280:	be df       	rcall	.-132    	; 0x21fe <vStartIntegerMathTasks>
    2282:	82 e0       	ldi	r24, 0x02	; 2
	}

	/* Demo AVR323 tasks */
	vStartIntegerMathTasks( tskIDLE_PRIORITY );
    2284:	40 e0       	ldi	r20, 0x00	; 0
    2286:	52 ec       	ldi	r21, 0xC2	; 194
    2288:	61 e0       	ldi	r22, 0x01	; 1
	vAltStartComTestTasks( mainCOM_TEST_PRIORITY, mainCOM_TEST_BAUD_RATE, mainCOM_TEST_LED );
    228a:	70 e0       	ldi	r23, 0x00	; 0
    228c:	25 e0       	ldi	r18, 0x05	; 5
    228e:	fc dd       	rcall	.-1032   	; 0x1e88 <vAltStartComTestTasks>
    2290:	82 e0       	ldi	r24, 0x02	; 2
    2292:	47 dd       	rcall	.-1394   	; 0x1d22 <vStartPolledQueueTasks>
    2294:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vStartRegTestTasks>
    2298:	81 e6       	ldi	r24, 0x61	; 97
	vStartPolledQueueTasks( mainQUEUE_POLL_PRIORITY );
    229a:	91 e1       	ldi	r25, 0x11	; 17
    229c:	6c e9       	ldi	r22, 0x9C	; 156
    229e:	72 e0       	ldi	r23, 0x02	; 2
	vStartRegTestTasks();
    22a0:	45 e5       	ldi	r20, 0x55	; 85
    22a2:	50 e0       	ldi	r21, 0x00	; 0

	/* Create the tasks defined within this file. */
	xTaskCreate( vErrorChecks, "Check", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL );
    22a4:	20 e0       	ldi	r18, 0x00	; 0
    22a6:	30 e0       	ldi	r19, 0x00	; 0
    22a8:	03 e0       	ldi	r16, 0x03	; 3
    22aa:	ee 24       	eor	r14, r14
    22ac:	ff 24       	eor	r15, r15
    22ae:	08 dc       	rcall	.-2032   	; 0x1ac0 <xTaskCreate>
    22b0:	83 e0       	ldi	r24, 0x03	; 3
    22b2:	7a de       	rcall	.-780    	; 0x1fa8 <vStartFlashCoRoutines>
    22b4:	f8 dc       	rcall	.-1552   	; 0x1ca6 <vTaskStartScheduler>
    22b6:	80 e0       	ldi	r24, 0x00	; 0
    22b8:	90 e0       	ldi	r25, 0x00	; 0
    22ba:	0f 91       	pop	r16
    22bc:	ff 90       	pop	r15

	/* Create the co-routines that flash the LED's. */
	vStartFlashCoRoutines( mainNUM_FLASH_COROUTINES );
    22be:	ef 90       	pop	r14
    22c0:	08 95       	ret

000022c2 <vErrorChecks>:
	}
}
/*-----------------------------------------------------------*/

static void vErrorChecks( void *pvParameters )
{
    22c2:	1f 93       	push	r17
{
static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
	{
		xErrorHasOccurred = pdTRUE;
    22c4:	11 e0       	ldi	r17, 0x01	; 1

	/* Cycle for ever, delaying then checking all the other tasks are still
	operating without error. */
	for( ;; )
	{
		vTaskDelay( mainCHECK_PERIOD );
    22c6:	88 eb       	ldi	r24, 0xB8	; 184
    22c8:	9b e0       	ldi	r25, 0x0B	; 11
    22ca:	66 db       	rcall	.-2356   	; 0x1998 <vTaskDelay>
    22cc:	20 91 a4 02 	lds	r18, 0x02A4

		/* Perform a bit of 32bit maths to ensure the registers used by the
		integer tasks get some exercise. The result here is not important -
		see the demo application documentation for more info. */
		ulDummyVariable *= 3;
    22d0:	30 91 a5 02 	lds	r19, 0x02A5
    22d4:	40 91 a6 02 	lds	r20, 0x02A6
    22d8:	50 91 a7 02 	lds	r21, 0x02A7
    22dc:	da 01       	movw	r26, r20
    22de:	c9 01       	movw	r24, r18
    22e0:	88 0f       	add	r24, r24
    22e2:	99 1f       	adc	r25, r25
    22e4:	aa 1f       	adc	r26, r26
    22e6:	bb 1f       	adc	r27, r27
    22e8:	82 0f       	add	r24, r18
    22ea:	93 1f       	adc	r25, r19
    22ec:	a4 1f       	adc	r26, r20
    22ee:	b5 1f       	adc	r27, r21
    22f0:	80 93 a4 02 	sts	0x02A4, r24
    22f4:	90 93 a5 02 	sts	0x02A5, r25
    22f8:	a0 93 a6 02 	sts	0x02A6, r26
    22fc:	b0 93 a7 02 	sts	0x02A7, r27
    2300:	77 df       	rcall	.-274    	; 0x21f0 <xAreIntegerMathsTaskStillRunning>

static void prvCheckOtherTasksAreStillRunning( void )
{
static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
    2302:	81 30       	cpi	r24, 0x01	; 1
    2304:	11 f0       	breq	.+4      	; 0x230a <vErrorChecks+0x48>
    2306:	10 93 a1 20 	sts	0x20A1, r17
	{
		xErrorHasOccurred = pdTRUE;
    230a:	b7 dd       	rcall	.-1170   	; 0x1e7a <xAreComTestTasksStillRunning>
    230c:	81 30       	cpi	r24, 0x01	; 1
	}

	if( xAreComTestTasksStillRunning() != pdTRUE )
    230e:	11 f0       	breq	.+4      	; 0x2314 <vErrorChecks+0x52>
    2310:	10 93 a1 20 	sts	0x20A1, r17
    2314:	f9 dc       	rcall	.-1550   	; 0x1d08 <xArePollingQueuesStillRunning>
	{
		xErrorHasOccurred = pdTRUE;
    2316:	81 30       	cpi	r24, 0x01	; 1
    2318:	11 f0       	breq	.+4      	; 0x231e <vErrorChecks+0x5c>
	}

	if( xArePollingQueuesStillRunning() != pdTRUE )
    231a:	10 93 a1 20 	sts	0x20A1, r17
    231e:	0e 94 99 01 	call	0x332	; 0x332 <xAreRegTestTasksStillRunning>
	{
		xErrorHasOccurred = pdTRUE;
    2322:	81 30       	cpi	r24, 0x01	; 1
    2324:	11 f0       	breq	.+4      	; 0x232a <vErrorChecks+0x68>
	}

	if( xAreRegTestTasksStillRunning() != pdTRUE )
    2326:	10 93 a1 20 	sts	0x20A1, r17
    232a:	80 91 a1 20 	lds	r24, 0x20A1
	{
		xErrorHasOccurred = pdTRUE;
    232e:	88 23       	and	r24, r24
    2330:	51 f6       	brne	.-108    	; 0x22c6 <vErrorChecks+0x4>
	}

	if( xErrorHasOccurred == pdFALSE )
    2332:	84 e0       	ldi	r24, 0x04	; 4
    2334:	0e 94 0e 03 	call	0x61c	; 0x61c <vParTestToggleLED>
    2338:	c6 cf       	rjmp	.-116    	; 0x22c6 <vErrorChecks+0x4>

0000233a <prvQueueSendTask>:
	return 0;
}
/*-----------------------------------------------------------*/

static void prvQueueSendTask( void *pvParameters )
{
    233a:	ef 92       	push	r14
    233c:	ff 92       	push	r15
    233e:	0f 93       	push	r16
    2340:	1f 93       	push	r17
    2342:	df 93       	push	r29
    2344:	cf 93       	push	r28
    2346:	00 d0       	rcall	.+0      	; 0x2348 <prvQueueSendTask+0xe>
    2348:	cd b7       	in	r28, 0x3d	; 61
    234a:	de b7       	in	r29, 0x3e	; 62
TickType_t xNextWakeTime;
const unsigned char ucValueToSend = 100;
    234c:	24 e6       	ldi	r18, 0x64	; 100
    234e:	29 83       	std	Y+1, r18	; 0x01
	/* Remove compiler warning in the case that configASSERT() is not
	defined. */
	( void ) pvParameters;

	/* Check the task parameter is as expected. */
	configASSERT( ( ( unsigned int ) pvParameters ) == mainDEMOBLINKY_SEND_PARAMETER );
    2350:	81 51       	subi	r24, 0x11	; 17
    2352:	91 41       	sbci	r25, 0x11	; 17
    2354:	21 f0       	breq	.+8      	; 0x235e <prvQueueSendTask+0x24>
{
	/* Parameters are not used. */
	( void ) ulLine;
	( void ) pcFileName;

	vParTestSetLED(mainASSERTCALLED_LED, pdTRUE);
    2356:	87 e0       	ldi	r24, 0x07	; 7
    2358:	61 e0       	ldi	r22, 0x01	; 1
    235a:	0e 94 25 03 	call	0x64a	; 0x64a <vParTestSetLED>

	/* Check the task parameter is as expected. */
	configASSERT( ( ( unsigned int ) pvParameters ) == mainDEMOBLINKY_SEND_PARAMETER );

	/* Initialize xNextWakeTime - this only needs to be done once. */
	xNextWakeTime = xTaskGetTickCount();
    235e:	74 d8       	rcall	.-3864   	; 0x1448 <xTaskGetTickCount>
    2360:	9b 83       	std	Y+3, r25	; 0x03
    2362:	8a 83       	std	Y+2, r24	; 0x02
    2364:	72 e0       	ldi	r23, 0x02	; 2
	{
		/* Place this task in the blocked state until it is time to run again.
		The block time is specified in ticks, the constant used converts ticks
		to ms.  While in the Blocked state this task will not consume any CPU
		time. */
		vTaskDelayUntil( &xNextWakeTime, xBlockTime );
    2366:	e7 2e       	mov	r14, r23
    2368:	f1 2c       	mov	r15, r1
    236a:	ec 0e       	add	r14, r28
    236c:	fd 1e       	adc	r15, r29
    236e:	8e 01       	movw	r16, r28

		/* Send to the queue - causing the queue receive task to unblock and
		toggle the LED.  0 is used as the block time so the sending operation
		will not block - it shouldn't need to block as the queue should always
		be empty at this point in the code. */
		xQueueSend( xQueue, &ucValueToSend, 0U );
    2370:	0f 5f       	subi	r16, 0xFF	; 255
    2372:	1f 4f       	sbci	r17, 0xFF	; 255
    2374:	c7 01       	movw	r24, r14
	{
		/* Place this task in the blocked state until it is time to run again.
		The block time is specified in ticks, the constant used converts ticks
		to ms.  While in the Blocked state this task will not consume any CPU
		time. */
		vTaskDelayUntil( &xNextWakeTime, xBlockTime );
    2376:	68 ec       	ldi	r22, 0xC8	; 200
    2378:	70 e0       	ldi	r23, 0x00	; 0
    237a:	2e db       	rcall	.-2468   	; 0x19d8 <vTaskDelayUntil>
    237c:	80 91 9f 20 	lds	r24, 0x209F

		/* Send to the queue - causing the queue receive task to unblock and
		toggle the LED.  0 is used as the block time so the sending operation
		will not block - it shouldn't need to block as the queue should always
		be empty at this point in the code. */
		xQueueSend( xQueue, &ucValueToSend, 0U );
    2380:	90 91 a0 20 	lds	r25, 0x20A0
    2384:	b8 01       	movw	r22, r16
    2386:	40 e0       	ldi	r20, 0x00	; 0
    2388:	50 e0       	ldi	r21, 0x00	; 0
    238a:	20 e0       	ldi	r18, 0x00	; 0
    238c:	0e 94 de 08 	call	0x11bc	; 0x11bc <xQueueGenericSend>
    2390:	f1 cf       	rjmp	.-30     	; 0x2374 <prvQueueSendTask+0x3a>

00002392 <prvQueueReceiveTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvQueueReceiveTask( void *pvParameters )
{
    2392:	0f 93       	push	r16
    2394:	1f 93       	push	r17
    2396:	df 93       	push	r29
    2398:	cf 93       	push	r28
    239a:	0f 92       	push	r0
    239c:	cd b7       	in	r28, 0x3d	; 61
    239e:	de b7       	in	r29, 0x3e	; 62
	/* Remove compiler warning in the case that configASSERT() is not
	defined. */
	( void ) pvParameters;

	/* Check the task parameter is as expected. */
	configASSERT( ( ( unsigned int ) pvParameters ) == mainDEMOBLINKY_RECEIVE_PARAMETER );
    23a0:	82 97       	sbiw	r24, 0x22	; 34
    23a2:	21 f0       	breq	.+8      	; 0x23ac <prvQueueReceiveTask+0x1a>
{
	/* Parameters are not used. */
	( void ) ulLine;
	( void ) pcFileName;

	vParTestSetLED(mainASSERTCALLED_LED, pdTRUE);
    23a4:	87 e0       	ldi	r24, 0x07	; 7
    23a6:	61 e0       	ldi	r22, 0x01	; 1
    23a8:	0e 94 25 03 	call	0x64a	; 0x64a <vParTestSetLED>
	for( ;; )
	{
		/* Wait until something arrives in the queue - this task will block
		indefinitely provided INCLUDE_vTaskSuspend is set to 1 in
		FreeRTOSConfig.h. */
		xQueueReceive( xQueue, &ucReceivedValue, portMAX_DELAY );
    23ac:	8e 01       	movw	r16, r28
    23ae:	0f 5f       	subi	r16, 0xFF	; 255
    23b0:	1f 4f       	sbci	r17, 0xFF	; 255
    23b2:	80 91 9f 20 	lds	r24, 0x209F
    23b6:	90 91 a0 20 	lds	r25, 0x20A0
    23ba:	b8 01       	movw	r22, r16
    23bc:	4f ef       	ldi	r20, 0xFF	; 255
    23be:	5f ef       	ldi	r21, 0xFF	; 255
    23c0:	20 e0       	ldi	r18, 0x00	; 0
    23c2:	0e 94 17 08 	call	0x102e	; 0x102e <xQueueGenericReceive>

		/*  To get here something must have been received from the queue, but
		is it the expected value?  If it is, toggle the LED. */
		if( ucReceivedValue == 100UL )
    23c6:	89 81       	ldd	r24, Y+1	; 0x01
    23c8:	84 36       	cpi	r24, 0x64	; 100
    23ca:	99 f7       	brne	.-26     	; 0x23b2 <prvQueueReceiveTask+0x20>
		{
			/* The Windows Blinky Demo prints a message with printf().
			 * In Arduino, we'll just blink a LED */
			vParTestToggleLED(mainDEMOBLINKY_LED);
    23cc:	86 e0       	ldi	r24, 0x06	; 6
    23ce:	0e 94 0e 03 	call	0x61c	; 0x61c <vParTestToggleLED>

			ucReceivedValue = 0U;
    23d2:	19 82       	std	Y+1, r1	; 0x01
    23d4:	ee cf       	rjmp	.-36     	; 0x23b2 <prvQueueReceiveTask+0x20>

000023d6 <__mulsi3>:
    23d6:	62 9f       	mul	r22, r18
    23d8:	d0 01       	movw	r26, r0
    23da:	73 9f       	mul	r23, r19
    23dc:	f0 01       	movw	r30, r0
    23de:	82 9f       	mul	r24, r18
    23e0:	e0 0d       	add	r30, r0
    23e2:	f1 1d       	adc	r31, r1
    23e4:	64 9f       	mul	r22, r20
    23e6:	e0 0d       	add	r30, r0
    23e8:	f1 1d       	adc	r31, r1
    23ea:	92 9f       	mul	r25, r18
    23ec:	f0 0d       	add	r31, r0
    23ee:	83 9f       	mul	r24, r19
    23f0:	f0 0d       	add	r31, r0
    23f2:	74 9f       	mul	r23, r20
    23f4:	f0 0d       	add	r31, r0
    23f6:	65 9f       	mul	r22, r21
    23f8:	f0 0d       	add	r31, r0
    23fa:	99 27       	eor	r25, r25
    23fc:	72 9f       	mul	r23, r18
    23fe:	b0 0d       	add	r27, r0
    2400:	e1 1d       	adc	r30, r1
    2402:	f9 1f       	adc	r31, r25
    2404:	63 9f       	mul	r22, r19
    2406:	b0 0d       	add	r27, r0
    2408:	e1 1d       	adc	r30, r1
    240a:	f9 1f       	adc	r31, r25
    240c:	bd 01       	movw	r22, r26
    240e:	cf 01       	movw	r24, r30
    2410:	11 24       	eor	r1, r1
    2412:	08 95       	ret

00002414 <__udivmodhi4>:
    2414:	aa 1b       	sub	r26, r26
    2416:	bb 1b       	sub	r27, r27
    2418:	51 e1       	ldi	r21, 0x11	; 17
    241a:	07 c0       	rjmp	.+14     	; 0x242a <__udivmodhi4_ep>

0000241c <__udivmodhi4_loop>:
    241c:	aa 1f       	adc	r26, r26
    241e:	bb 1f       	adc	r27, r27
    2420:	a6 17       	cp	r26, r22
    2422:	b7 07       	cpc	r27, r23
    2424:	10 f0       	brcs	.+4      	; 0x242a <__udivmodhi4_ep>
    2426:	a6 1b       	sub	r26, r22
    2428:	b7 0b       	sbc	r27, r23

0000242a <__udivmodhi4_ep>:
    242a:	88 1f       	adc	r24, r24
    242c:	99 1f       	adc	r25, r25
    242e:	5a 95       	dec	r21
    2430:	a9 f7       	brne	.-22     	; 0x241c <__udivmodhi4_loop>
    2432:	80 95       	com	r24
    2434:	90 95       	com	r25
    2436:	bc 01       	movw	r22, r24
    2438:	cd 01       	movw	r24, r26
    243a:	08 95       	ret

0000243c <__udivmodsi4>:
    243c:	a1 e2       	ldi	r26, 0x21	; 33
    243e:	1a 2e       	mov	r1, r26
    2440:	aa 1b       	sub	r26, r26
    2442:	bb 1b       	sub	r27, r27
    2444:	fd 01       	movw	r30, r26
    2446:	0d c0       	rjmp	.+26     	; 0x2462 <__udivmodsi4_ep>

00002448 <__udivmodsi4_loop>:
    2448:	aa 1f       	adc	r26, r26
    244a:	bb 1f       	adc	r27, r27
    244c:	ee 1f       	adc	r30, r30
    244e:	ff 1f       	adc	r31, r31
    2450:	a2 17       	cp	r26, r18
    2452:	b3 07       	cpc	r27, r19
    2454:	e4 07       	cpc	r30, r20
    2456:	f5 07       	cpc	r31, r21
    2458:	20 f0       	brcs	.+8      	; 0x2462 <__udivmodsi4_ep>
    245a:	a2 1b       	sub	r26, r18
    245c:	b3 0b       	sbc	r27, r19
    245e:	e4 0b       	sbc	r30, r20
    2460:	f5 0b       	sbc	r31, r21

00002462 <__udivmodsi4_ep>:
    2462:	66 1f       	adc	r22, r22
    2464:	77 1f       	adc	r23, r23
    2466:	88 1f       	adc	r24, r24
    2468:	99 1f       	adc	r25, r25
    246a:	1a 94       	dec	r1
    246c:	69 f7       	brne	.-38     	; 0x2448 <__udivmodsi4_loop>
    246e:	60 95       	com	r22
    2470:	70 95       	com	r23
    2472:	80 95       	com	r24
    2474:	90 95       	com	r25
    2476:	9b 01       	movw	r18, r22
    2478:	ac 01       	movw	r20, r24
    247a:	bd 01       	movw	r22, r26
    247c:	cf 01       	movw	r24, r30
    247e:	08 95       	ret

00002480 <__divmodsi4>:
    2480:	97 fb       	bst	r25, 7
    2482:	09 2e       	mov	r0, r25
    2484:	05 26       	eor	r0, r21
    2486:	0e d0       	rcall	.+28     	; 0x24a4 <__divmodsi4_neg1>
    2488:	57 fd       	sbrc	r21, 7
    248a:	04 d0       	rcall	.+8      	; 0x2494 <__divmodsi4_neg2>
    248c:	d7 df       	rcall	.-82     	; 0x243c <__udivmodsi4>
    248e:	0a d0       	rcall	.+20     	; 0x24a4 <__divmodsi4_neg1>
    2490:	00 1c       	adc	r0, r0
    2492:	38 f4       	brcc	.+14     	; 0x24a2 <__divmodsi4_exit>

00002494 <__divmodsi4_neg2>:
    2494:	50 95       	com	r21
    2496:	40 95       	com	r20
    2498:	30 95       	com	r19
    249a:	21 95       	neg	r18
    249c:	3f 4f       	sbci	r19, 0xFF	; 255
    249e:	4f 4f       	sbci	r20, 0xFF	; 255
    24a0:	5f 4f       	sbci	r21, 0xFF	; 255

000024a2 <__divmodsi4_exit>:
    24a2:	08 95       	ret

000024a4 <__divmodsi4_neg1>:
    24a4:	f6 f7       	brtc	.-4      	; 0x24a2 <__divmodsi4_exit>
    24a6:	90 95       	com	r25
    24a8:	80 95       	com	r24
    24aa:	70 95       	com	r23
    24ac:	61 95       	neg	r22
    24ae:	7f 4f       	sbci	r23, 0xFF	; 255
    24b0:	8f 4f       	sbci	r24, 0xFF	; 255
    24b2:	9f 4f       	sbci	r25, 0xFF	; 255
    24b4:	08 95       	ret

000024b6 <memcpy>:
    24b6:	fb 01       	movw	r30, r22
    24b8:	dc 01       	movw	r26, r24
    24ba:	02 c0       	rjmp	.+4      	; 0x24c0 <memcpy+0xa>
    24bc:	01 90       	ld	r0, Z+
    24be:	0d 92       	st	X+, r0
    24c0:	41 50       	subi	r20, 0x01	; 1
    24c2:	50 40       	sbci	r21, 0x00	; 0
    24c4:	d8 f7       	brcc	.-10     	; 0x24bc <memcpy+0x6>
    24c6:	08 95       	ret

000024c8 <_exit>:
    24c8:	f8 94       	cli

000024ca <__stop_program>:
    24ca:	ff cf       	rjmp	.-2      	; 0x24ca <__stop_program>
